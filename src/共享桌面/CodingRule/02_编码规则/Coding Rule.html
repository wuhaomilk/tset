<!DOCTYPE html>
<!-- saved from url=(0046)http://review.iauto.net/developrule/CodingRule -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <link rel="stylesheet" type="text/css" href="./Coding Rule_files/gollum.css" media="all">
  <link rel="stylesheet" type="text/css" href="./Coding Rule_files/editor.css" media="all">
  <link rel="stylesheet" type="text/css" href="./Coding Rule_files/dialog.css" media="all">
  <link rel="stylesheet" type="text/css" href="./Coding Rule_files/template.css" media="all">
  <link rel="stylesheet" type="text/css" href="./Coding Rule_files/print.css" media="print">
  
  

  <!--[if IE 7]>
  <link rel="stylesheet" type="text/css" href="/css/ie7.css" media="all">
  <![endif]-->

  <script>
      var baseUrl = '';
      var pageFullPath = 'developrule/CodingRule';
      var uploadDest   = '';
  </script>
  <script type="text/javascript" src="./Coding Rule_files/jquery-1.7.2.min.js.下载"></script>
  <script type="text/javascript" src="./Coding Rule_files/mousetrap.min.js.下载"></script>
  <script type="text/javascript" src="./Coding Rule_files/gollum.js.下载"></script>
  <script type="text/javascript" src="./Coding Rule_files/gollum.dialog.js.下载"></script>
  <script type="text/javascript" src="./Coding Rule_files/gollum.placeholder.js.下载"></script>
  <script type="text/javascript" src="./Coding Rule_files/gollum.editor.js.下载"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath:  [ ['\\(','\\)'] ],
      displayMath: [ ['$$','$$'], ['\\[','\\]'] ],
      processEscapes: true
    },
    TeX: { extensions: ["autoload-all.js"] }});
  </script>
  <script>(function(d,j){
  j = d.createElement('script');
  j.src = 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
  (d.head || d.getElementsByTagName('head')[0]).appendChild(j);
  }(document));
  </script><script src="./Coding Rule_files/MathJax.js.下载"></script>
  

  <title>Coding Rule</title>
</head>
<body class="webkit">

<script>
Mousetrap.bind(['e'], function( e ) {
  e.preventDefault();
  window.location = "/edit" + window.location.pathname;
  return false;
});
</script>
<div id="wiki-wrapper" class="page">
<div id="head">
  <h1>Coding Rule</h1>
  <ul class="actions">
    <li class="minibutton">
      <div id="searchbar">
        <form action="http://review.iauto.net/search" method="get" id="search-form">
        <div id="searchbar-fauxtext">
          <input type="text" name="q" id="search-query" value="Search…" autocomplete="off" class="ph">
          <a href="http://review.iauto.net/developrule/CodingRule#" id="search-submit" title="Search this wiki">
            <span>Search</span>
          </a>
        </div>
        </form>
      </div>    </li>
    <li class="minibutton"><a href="http://review.iauto.net/" class="action-home-page">Home</a></li>
    <li class="minibutton"><a href="http://review.iauto.net/pages" class="action-all-pages">All</a></li>
    <li class="minibutton"><a href="http://review.iauto.net/fileview" class="action-fileview">Files</a></li>
    <li class="minibutton">
      <a href="http://review.iauto.net/developrule/CodingRule#" id="minibutton-new-page">New</a></li>
    <li class="minibutton">
      <a href="http://review.iauto.net/developrule/CodingRule#" id="minibutton-rename-page">Rename</a></li>
    <li class="minibutton"><a href="http://review.iauto.net/edit/developrule/CodingRule" class="action-edit-page">Edit</a></li>
    <li class="minibutton jaws">
    </li><li class="minibutton"><a href="http://review.iauto.net/history/developrule/CodingRule" class="action-page-history">History</a></li>
  </ul>
</div>
<div id="wiki-content">
<div class="">
  <div id="wiki-body" class="gollum-markdown-content">
    <div class="markdown-body">
      

<p></p><div class="toc"><div class="toc-title">Table of Contents</div><ul><li><a href="http://review.iauto.net/developrule/CodingRule#Coding-Rule">Coding Rule</a></li></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#1.-%E5%89%8D%E8%A8%80">1. 前言</a></li></ul></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#2.-%E7%AE%80%E4%BB%8B">2. 简介</a></li></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#2.1-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%9A%84%E5%86%85%E5%AE%B9">2.1 编程规范的内容</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#2.2-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%9A%84%E5%9F%BA%E5%87%86">2.2 编程规范的基准</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#2.2.1-%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7">2.2.1 代码的一致性</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#2.2.2-%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7">2.2.2 代码的可读性</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#2.2.3-%E4%BB%A3%E7%A0%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7">2.2.3 代码的正确性</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#2.2.4-%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87">2.2.4 代码的执行效率</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#2.2.5-%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87">2.2.5 提高开发效率</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#2.3-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%8C%87%E5%AE%9A%E4%B8%8A%E7%9A%84%E8%80%83%E8%99%91">2.3 编程规范指定上的考虑</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#2.4-%E9%98%85%E8%AF%BB%E6%9C%AC%E8%A7%84%E8%8C%83%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%9C%E8%A5%BF">2.4 阅读本规范需要注意的东西</a></li></ul></ul></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.-%E6%96%87%E4%BB%B6%E8%A7%84%E8%8C%83">3. 文件规范</a></li></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.1-%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D">3.1 文件命名</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.1.1-%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">3.1.1 基本文件命名规则</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.1.2-%E6%89%A9%E5%B1%95%E5%90%8D">3.1.2 扩展名</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.1.3-%E6%96%87%E4%BB%B6%E5%90%8D">3.1.3 文件名</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.2-%E6%96%87%E4%BB%B6%E5%86%85%E7%9A%84%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F">3.2 文件内的排列顺序</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.2.1-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F">3.2.1 头文件的排列顺序</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.2.2-C/C++%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F">3.2.2 C/C++源文件的排列顺序</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.3-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%A7%84%E8%8C%83">3.3 头文件包含规范</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.3.1-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%A7%84%E5%88%99">3.3.1 头文件包含规则</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.3.2-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%85%E5%90%AB%E9%A1%BA%E5%BA%8F">3.3.2 头文件的包含顺序</a></li></ul></ul></ul></ul><ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.3.2.1-%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6">3.3.2.1 系统头文件</a></li></ul></ul></ul></ul></ul><ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.3.2.2-%E5%A4%96%E9%83%A8%E5%A4%B4%E6%96%87%E4%BB%B6">3.3.2.2 外部头文件</a></li></ul></ul></ul></ul></ul><ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.3.2.3-%E5%86%85%E9%83%A8%E5%A4%B4%E6%96%87%E4%BB%B6">3.3.2.3 内部头文件</a></li></ul></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.3.3-%E4%B8%8D%E8%A6%81%E5%8C%85%E5%90%AB%E6%97%A0%E7%94%A8%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6">3.3.3 不要包含无用的头文件</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.3.4-%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6%E6%97%B6%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84">3.3.4 包含头文件时使用相对路径</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.3.5-%E9%80%9A%E8%BF%87%E6%98%BE%E7%A4%BA%E7%9A%84%E7%B1%BB%E5%A3%B0%E6%98%8E%E9%81%BF%E5%85%8D%E5%BC%95%E5%85%A5%E8%BF%87%E5%A4%9A%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6">3.3.5 通过显示的类声明避免引入过多的头文件</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.3.6-%E5%8C%85%E5%90%AB%E5%A4%96%E9%83%A8%E5%85%AC%E5%BC%80%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6">3.3.6 包含外部公开的头文件</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.4-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%85%E5%90%AB%E4%BF%9D%E6%8A%A4">3.4 头文件的包含保护</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.4.1-%E5%8C%85%E5%90%AB%E4%BF%9D%E6%8A%A4%E5%AE%8F%E7%9A%84%E5%AE%9A%E4%B9%89">3.4.1 包含保护宏的定义</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.4.2-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%8C%85%E5%90%AB%E4%BF%9D%E6%8A%A4">3.4.2 头文件中的包含保护</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.4.3-%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%8C%85%E5%90%AB%E4%BF%9D%E6%8A%A4">3.4.3 源文件中的包含保护</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.5-%E6%B3%A8%E6%98%8EC++%E5%A4%B4%E6%96%87%E4%BB%B6">3.5 注明C++头文件</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.6-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E8%A7%84%E5%88%99">3.6 头文件中的其他规则</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.6.1-%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F">3.6.1 不要在头文件中定义变量</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#3.6.2-%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8using-namespace">3.6.2 不要在头文件中使用using namespace</a></li></ul></ul></ul></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.-%E7%BC%A9%E8%BF%9B%E4%B8%8E%E6%8D%A2%E8%A1%8C">4. 缩进与换行</a></li></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.1-%E7%BC%A9%E8%BF%9B%E7%9A%84%E6%A0%BC%E5%BC%8F">4.1 缩进的格式</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.2-%E9%81%BF%E5%85%8D%E9%95%BF%E8%A1%8C">4.2 避免长行</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.3-%E5%87%BD%E6%95%B0%E7%9A%84%E6%8D%A2%E8%A1%8C">4.3 函数的换行</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.3.1-%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C%E8%A6%81%E4%BB%A5%E5%8F%82%E6%95%B0%E4%B8%BA%E8%B5%B7%E7%82%B9">4.3.1 函数中的换行要以参数为起点</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.3.2-%E6%96%B0%E8%A1%8C%E7%9A%84%E7%BC%A9%E8%BF%9B%E6%96%B9%E5%BC%8F">4.3.2 新行的缩进方式</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.3.3-%E5%87%BD%E6%95%B0%E4%BD%93%E7%9A%84%E6%8D%A2%E8%A1%8C">4.3.3 函数体的换行</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.4-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C">4.4 表达式中的换行</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.4.1-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C">4.4.1 条件表达式中的换行</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.4.2-%E5%90%AB%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%8D%A2%E8%A1%8C">4.4.2 含运算符的赋值语句的换行</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.4.3-%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C">4.4.3 三元操作中的换行</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.5-%E5%90%AB%E6%9C%89%E6%88%90%E5%91%98%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C">4.5 含有成员的定义中的换行</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.6-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C">4.6 构造函数的初始化列表中的换行</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.7-%E4%BD%8D%E5%9F%9F%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C">4.7 位域定义中的换行</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#4.8-namespace%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C">4.8 namespace中的换行</a></li></ul></ul></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.-%E7%A9%BA%E8%A1%8C%E4%B8%8E%E7%A9%BA%E6%A0%BC">5. 空行与空格</a></li></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.1-%E7%94%A8%E7%A9%BA%E8%A1%8C%E5%AF%B9%E4%BB%A3%E7%A0%81%E2%80%9C%E5%88%86%E5%8C%BA%E2%80%9D">5.1 用空行对代码“分区”</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.2-%E7%94%A8%E7%A9%BA%E8%A1%8C%E5%AF%B9%E4%BB%A3%E7%A0%81%E2%80%9C%E5%88%86%E7%BB%84%E2%80%9D">5.2 用空行对代码“分组”</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.2.1-%E6%A0%B9%E6%8D%AE%E5%A4%B4%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%8D%E5%90%8C%E5%88%86%E7%BB%84">5.2.1 根据头文件类型的不同分组</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.2.2-%E6%A0%B9%E6%8D%AE%E5%8A%9F%E8%83%BD%E5%88%86%E7%BB%84">5.2.2 根据功能分组</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.2.3-%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89">5.2.3 类型定义</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.2.4-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89">5.2.4 函数定义</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.3-%E7%94%A8%E7%A9%BA%E8%A1%8C%E5%88%86%E9%9A%94%E9%80%BB%E8%BE%91%E5%9D%97">5.3 用空行分隔逻辑块</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.4-%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%86%85%E9%83%A8%E7%9A%84%E7%A9%BA%E8%A1%8C">5.4 类定义内部的空行</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.4.1-%E4%B8%8D%E5%90%8C%E5%8C%BA%E5%9F%9F%E9%97%B4%E7%9A%84%E7%A9%BA%E8%A1%8C">5.4.1 不同区域间的空行</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.4.2-%E5%8A%9F%E8%83%BD%E5%88%86%E7%BB%84">5.4.2 功能分组</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.4.3-%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%88%AB%E6%88%90%E5%91%98">5.4.3 不同类别成员</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.4.4-%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%A9%BA%E8%A1%8C">5.4.4 函数之间空行</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.4.5-%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84%E7%9A%84%E4%BE%8B%E5%AD%90">5.4.5 类定义分组的例子</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.5-%E7%A9%BA%E6%A0%BC%E7%9A%84%E4%BD%BF%E7%94%A8">5.5 空格的使用</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.5.1-%E7%94%A8%E7%A9%BA%E6%A0%BC%E7%AA%81%E5%87%BA%E5%85%B3%E9%94%AE%E5%AD%97">5.5.1 用空格突出关键字</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.5.2-%E6%8B%AC%E5%8F%B7">5.5.2 括号</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.5.3-%E9%80%97%E5%8F%B7%E5%92%8C%E5%88%86%E5%8F%B7">5.5.3 逗号和分号</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.5.4-%E4%BA%8C%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6">5.5.4 二元操作符</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.5.5-%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6">5.5.5 一元操作符</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.5.6-%E4%B8%8D%E8%A6%81%E5%86%97%E4%BD%99%E7%9A%84%E7%A9%BA%E6%A0%BC">5.5.6 不要冗余的空格</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.5.7-%E4%BE%8B%E5%AD%90">5.5.7 例子</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.5.8-%E6%B3%A8%E9%87%8A%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC">5.5.8 注释中的空格</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.5.9-%E5%85%B6%E4%BB%96">5.5.9 其他</a></li></ul></ul></ul></ul><ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.5.9.1-%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC">5.5.9.1 三元操作中的空格</a></li></ul></ul></ul></ul></ul><ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.5.9.2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC">5.5.9.2 构造函数的初始化列表中的空格</a></li></ul></ul></ul></ul></ul><ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#5.5.9.3-%E4%BD%8D%E5%9F%9F%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC">5.5.9.3 位域中的空格</a></li></ul></ul></ul></ul></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.-%E4%BB%A3%E7%A0%81">6. 代码</a></li></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.1-%E6%AF%8F%E6%9D%A1%E8%AF%AD%E5%8F%A5%E4%B8%80%E4%B8%AA%E9%80%BB%E8%BE%91">6.1 每条语句一个逻辑</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.1.1-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E6%97%B6%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD">6.1.1 条件表达时中的逻辑判断</a></li></ul></ul></ul></ul><ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.1.1.1-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C">6.1.1.1 条件表达式中的赋值操作</a></li></ul></ul></ul></ul></ul><ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.1.1.2-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">6.1.1.2 条件表达式中的函数调用</a></li></ul></ul></ul></ul></ul><ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.1.1.3-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97">6.1.1.3 条件表达式中的算数运算</a></li></ul></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.1.2-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8">6.1.2 函数调用</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.2-%E6%8B%AC%E5%8F%B7">6.2 括号</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.2.1-%E7%94%A8%E6%8B%AC%E5%8F%B7%E9%81%BF%E5%85%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98">6.2.1 用括号避免操作符优先级问题</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.2.2-%E5%9C%A8%E5%AE%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8B%AC%E5%8F%B7">6.2.2 在宏中使用括号</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.3-%E6%AF%94%E8%BE%83">6.3 比较</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.3.1-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%AF%94%E8%BE%83">6.3.1 整数类型与常量比较</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.3.2-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%AF%94%E8%BE%83">6.3.2 指针类型与常量比较</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.3.3-%E9%81%BF%E5%85%8D%E5%B8%B8%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83">6.3.3 避免常量字符串的直接比较</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.3.4-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83">6.3.4 布尔类型的比较</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.3.5-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83">6.3.5 浮点数的比较</a></li></ul></ul></ul></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.4-%E5%B8%B8%E9%87%8F">6.4 常量</a></li></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.4.1-%E9%81%BF%E5%85%8D%E5%B8%B8%E6%95%B0">6.4.1 避免常数</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.4.2-%E4%BD%BF%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%B8%B8%E6%95%B0">6.4.2 使用正确的常数</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.5-%E5%8F%98%E9%87%8F">6.5 变量</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.5.1-%E6%AF%8F%E8%A1%8C%E5%8F%AA%E5%A3%B0%E6%98%8E/%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F">6.5.1 每行只声明/定义一个变量</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.5.2-%E5%8F%98%E9%87%8F%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96">6.5.2 变量在定义时初始化</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.5.3-C%E7%B1%BB%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96">6.5.3 C类型结构体初始化</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.5.4-C++%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">6.5.4 C++类型的结构体与类的初始化</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.5.5-%E9%81%BF%E5%85%8D%E5%8F%98%E9%87%8F%E5%90%8D%E8%A6%86%E7%9B%96">6.5.5 避免变量名覆盖</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#6.6-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4">6.6 预处理指令</a></li></ul></ul></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#7.-%E6%8E%A7%E5%88%B6%E6%B5%81">7. 控制流</a></li></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#7.1-if%E7%9A%84%E5%86%99%E6%B3%95">7.1 if的写法</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#7.2-while%E7%9A%84%E5%86%99%E6%B3%95">7.2 while的写法</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#7.3-do...while%E7%9A%84%E5%86%99%E6%B3%95">7.3 do...while的写法</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#7.4-switch/case%E7%9A%84%E5%86%99%E6%B3%95">7.4 switch/case的写法</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#7.5-for%E7%9A%84%E5%86%99%E6%B3%95">7.5 for的写法</a></li></ul></ul></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">8. 命名规范</a></li></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.1-%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">8.1 命名规则</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.1.1-%E9%AA%86%E9%A9%BC%E5%91%BD%E5%90%8D%E6%B3%95">8.1.1 骆驼命名法</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.1.2-%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">8.1.2 变量命名规则</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.1.3-%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">8.1.3 函数命名规则</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.1.4-%E5%85%B6%E4%BB%96%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">8.1.4 其他命名规则</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.2-%E5%90%8D%E5%89%AF%E5%85%B6%E5%AE%9E">8.2 名副其实</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.2.1-%E4%BD%BF%E7%94%A8%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%8D%95%E8%AF%8D%E5%91%BD%E5%90%8D">8.2.1 使用有意义的单词命名</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.2.2-%E4%B8%8D%E8%A6%81%E4%BB%BB%E6%84%8F%E5%AF%B9%E5%8D%95%E8%AF%8D%E7%BC%A9%E5%86%99">8.2.2 不要任意对单词缩写</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.3-%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D">8.3 函数命名</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.3.1-%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%8E%9F%E5%88%99%EF%BC%88%E5%8A%A8%E8%AF%8D+%E5%90%8D%E8%AF%8D%EF%BC%89">8.3.1 自然语言原则（动词+名词）</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.3.2-%E9%85%8D%E5%AF%B9%E5%91%BD%E5%90%8D">8.3.2 配对命名</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.3.3-%E7%89%B9%E6%AE%8A%E7%9A%84%E9%85%8D%E5%AF%B9%EF%BC%9Aget/set">8.3.3 特殊的配对：get/set</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.3.4-%E7%89%B9%E6%AE%8A%E7%9A%84%E9%85%8D%E5%AF%B9%EF%BC%9Abool%E7%B1%BB%E5%9E%8B">8.3.4 特殊的配对：bool类型</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.3.5-%E9%81%BF%E5%85%8D%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E9%87%8D%E5%90%8D">8.3.5 避免与系统函数重名</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#8.3.6-%E9%81%BF%E5%85%8D%E5%A4%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E7%B1%BB%E5%90%8D">8.3.6 避免太简单的函数名和类名</a></li></ul></ul></ul></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#9.-%E7%B1%BB%E7%9A%84%E8%A7%84%E8%8C%83">9. 类的规范</a></li></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#9.1-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E8%A7%84%E8%8C%83">9.1 类成员变量/函数定义规范</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#9.1.1-%E4%B8%8D%E8%A6%81%E4%BE%9D%E8%B5%96%E4%BA%8E%E9%BB%98%E8%AE%A4%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">9.1.1 不要依赖于默认的访问权限</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#9.1.2-%E4%B8%8D%E8%A6%81%E5%AE%9A%E4%B9%89public%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F">9.1.2 不要定义public类型的成员变量</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#9.1.3-%E5%92%8C%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%AF%86%E5%88%87%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%AF%B7%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8">9.1.3 和类关系密切的类型，请定义在类的内部</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#9.1.4-class%E5%86%85%E7%9A%84%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F">9.1.4 class内的排列顺序</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#9.2-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81">9.2 继承与多态</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#9.2.1-%E9%81%BF%E5%85%8D%E5%A4%9A%E7%BB%A7%E6%89%BF">9.2.1 避免多继承</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#9.2.2-%E4%B8%8D%E8%A6%81%E6%8A%8A%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%94%BE%E5%88%B0%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1%E5%BE%88%E9%AB%98%E7%9A%84%E5%9F%BA%E7%B1%BB%E4%B8%AD">9.2.2 不要把不必要的方法放到抽象层次很高的基类中</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#9.3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">9.3 构造函数</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#9.3.1-%E9%81%BF%E5%85%8D%E9%BB%98%E8%AE%A4%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C=%E6%93%8D%E4%BD%9C%E7%AC%A6">9.3.1 避免默认复制构造函数和=操作符</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#9.3.2-%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8explicit%E5%85%B3%E9%94%AE%E5%AD%97">9.3.2 单个参数的类构造函数使用explicit关键字</a></li></ul></ul></ul></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#10.-%E5%87%BD%E6%95%B0">10. 函数</a></li></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#10.1-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">10.1 函数参数</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#10.1.1-%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E7%9A%84%E5%8F%82%E6%95%B0">10.1.1 避免过多的参数</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#10.1.2-%E9%81%BF%E5%85%8D%E5%80%BC%E4%BC%A0%E9%80%92">10.1.2 避免值传递</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#10.1.3-%E6%B3%A8%E6%84%8F%E5%8F%82%E6%95%B0%E9%A1%BA%E5%BA%8F">10.1.3 注意参数顺序</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#10.1.4-%E5%BD%A2%E5%8F%82%E5%90%8D%E4%B8%8D%E8%83%BD%E7%9C%81%E7%95%A5">10.1.4 形参名不能省略</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#10.2-%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0">10.2 使用内联函数</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#10.3-%E7%A7%AF%E6%9E%81%E4%BD%BF%E7%94%A8const">10.3 积极使用const</a></li></ul></ul></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#11.-%E5%86%85%E5%AD%98">11. 内存</a></li></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#11.1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">11.1 内存分配</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#11.2-%E5%A7%8B%E7%BB%88%E7%94%A8NULL%E8%A1%A8%E7%A4%BA%E6%97%A0%E6%95%88%E5%86%85%E5%AD%98">11.2 始终用NULL表示无效内存</a></li></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#11.3-%E6%85%8E%E9%87%8D%E5%AF%B9%E5%BE%85%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">11.3 慎重对待静态内存分配和栈内存分配</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#11.3.1-%E5%86%85%E5%AD%98%E5%86%97%E4%BD%99">11.3.1 内存冗余</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#11.3.2-%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D">11.3.2 静态分配</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#11.3.3-%E6%A0%88%E5%86%85%E5%88%86%E9%85%8D">11.3.3 栈内分配</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#11.3.4-%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E5%8F%AF%E5%8F%98%E9%95%BF%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89">11.3.4 禁止使用可变长的数组定义</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#11.4-%E6%85%8E%E7%94%A8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9CAPI">11.4 慎用C类型的内存操作API</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#11.4.1-%E4%B8%8D%E8%A6%81%E5%AF%B9%E9%9D%9E%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C">11.4.1 不要对非原生类型的变量使用内存操作</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#11.4.2-%E6%B3%A8%E6%84%8Fmemcpy%E7%9A%84overlap%E9%97%AE%E9%A2%98">11.4.2 注意memcpy的overlap问题</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#11.4.3-%E7%A6%81%E7%94%A8strcpy,-strcat,-sprintf">11.4.3 禁用strcpy, strcat, sprintf</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#11.5-%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BEnew!!!">11.5 内存释放new!!!</a></li></ul></ul></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.-%E6%B3%A8%E9%87%8A">12. 注释</a></li></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.1-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A">12.1 文档注释</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.1.1-%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A">12.1.1 文件注释</a></li></ul></ul></ul></ul><ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.1.1.1-%E5%A4%B4%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A">12.1.1.1 头文件注释</a></li></ul></ul></ul></ul></ul><ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.1.1.2-%E6%BA%90%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A">12.1.1.2 源文件注释</a></li></ul></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.1.2-class%E6%B3%A8%E9%87%8A">12.1.2 class注释</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.1.3-%E5%87%BD%E6%95%B0%E6%B3%A8%E9%87%8A">12.1.3 函数注释</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.1.4-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A">12.1.4 枚举类型注释</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.1.5-struct%E6%B3%A8%E9%87%8A">12.1.5 struct注释</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.1.6-%E5%85%B6%E4%BB%96%E6%B3%A8%E9%87%8A">12.1.6 其他注释</a></li></ul></ul></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.2-%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%E7%9A%84%E5%86%99%E6%B3%95">12.2 代码注释的写法</a></li></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.2.1-%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A">12.2.1 代码注释</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.2.2-%E4%B8%8D%E8%A6%81%E5%86%99%E6%97%A0%E7%94%A8%E7%9A%84%E6%B3%A8%E9%87%8A">12.2.2 不要写无用的注释</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.2.3-}%E5%92%8C#endif%E5%90%8E%E7%9A%84%E6%B3%A8%E9%87%8A">12.2.3 }和#endif后的注释</a></li></ul></ul></ul></ul><ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#12.2.4-%E7%94%A8#if-0-...-#endif%E5%8F%96%E4%BB%A3%E5%A4%A7%E6%AE%B5%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A">12.2.4 用#if 0 ... #endif取代大段的代码注释</a></li></ul></ul></ul></ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#13.-%E9%99%84%E5%BD%95A1-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%EF%BC%88OEM-T%E7%A4%BE%EF%BC%89">13. 附录A1-信息安全防御用代码规范（OEM-T社）</a></li></ul></ul><ul><ul><ul><li><a href="http://review.iauto.net/developrule/CodingRule#13.1~11-%E9%93%BE%E6%8E%A5">13.1~11 链接</a></li></ul></ul></ul></div>

<h2><a class="anchor" id="1.-前言" href="http://review.iauto.net/developrule/CodingRule#1.-%E5%89%8D%E8%A8%80"><i class="fa fa-link"></i></a>1. 前言</h2>

<p>本文适用于开发iAuto以及其衍生项目时应该遵守的编程规范。</p>

<p>编程规范对软件开发以及程序员来说非常重要，主要是因为软件的维护费用在整个软件的生存期里占有很大的比例，一般来说软件维护活动所花费的工作占整个生存期工作量的70%以上，一些大型系统的比例更高。</p>

<p>因此，为了更好的理解源代码，以方便进行软件维护，就需要制定编程规范，在早期编程阶段共同遵守这些规范。</p>

<p>所有的软件开发人员，必须遵守本文中规定的编程规范。</p>

<h2><a class="anchor" id="2.-简介" href="http://review.iauto.net/developrule/CodingRule#2.-%E7%AE%80%E4%BB%8B"><i class="fa fa-link"></i></a>2. 简介</h2>

<h3><a class="anchor" id="2.1-编程规范的内容" href="http://review.iauto.net/developrule/CodingRule#2.1-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%9A%84%E5%86%85%E5%AE%B9"><i class="fa fa-link"></i></a>2.1 编程规范的内容</h3>

<p>本编程规范侧重代码的行文规范，主要致力于提高代码的一致性和可读性，也是本规范的重中之重，占用了本文80%以上的篇幅。</p>

<p>另外，本规范中还会强调一部分编程习惯问题，以提高代码的正确性，代码执行效率和开发效率。但是如何提高代码的正确性是一个很大的话题，单独展开就可以写一本书了，所以不作为本规范中的重点内容。</p>

<h3><a class="anchor" id="2.2-编程规范的基准" href="http://review.iauto.net/developrule/CodingRule#2.2-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E7%9A%84%E5%9F%BA%E5%87%86"><i class="fa fa-link"></i></a>2.2 编程规范的基准</h3>

<p>本规范主要基于下面的要求来制定。</p>

<h4><a class="anchor" id="2.2.1-代码的一致性" href="http://review.iauto.net/developrule/CodingRule#2.2.1-%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><i class="fa fa-link"></i></a>2.2.1 代码的一致性</h4>

<p>很多人都有自己的编程习惯，比如有人喜欢用空格缩进，有人喜欢用Tab缩进；即使都用空格缩进也有不同，有人喜欢用4空格，有人喜欢用2空格，这就带来代码的不一致性。如果某个文件或者模块都是一个人写还好，如果多人修改过，那代码看起来就乱七八糟了，因为缩进有可能完全混乱了。看下面的这个例子：
</p><pre class="highlight">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 这里是Tab缩进
</span>      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="c1">// 这里是两空格缩
</span>  <span class="p">}</span>
</pre>


<h4><a class="anchor" id="2.2.2-代码的可读性" href="http://review.iauto.net/developrule/CodingRule#2.2.2-%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E8%AF%BB%E6%80%A7"><i class="fa fa-link"></i></a>2.2.2 代码的可读性</h4>

<p>好的编程规范能极大的提高代码的可读性，这对强调多人协同开发的大型项目来说尤为重要。代码的协作性表现在：</p>

<ul>
<li>直接协作

<ul>
<li>即组间协作，比如A组要用到B组提供的一个模块，如果A、B两组编程规范不一致，或者根本没有编程规范，那么A组要去消化B组提供的那套乱七八糟的代码可能要花很长时间，而且正确性也不能保证。</li>
</ul></li>
<li>代码Review

<ul>
<li>代码Review也是很重要的环节，如果代码不规范，可读性极差，那么Review的时间可能变得很长，而且Reviewer可能会随着极差代码心情变得极差，直接影响Review的效果。</li>
</ul></li>
<li>代码维护

<ul>
<li>没有太多人喜欢维护的工作，更没有人会把一个模块维护一辈子的，代码维护对象的变更是常有的事。遵守规范的代码会让代码交接工作变得简单，甚至会让后来者从中受益；没有规范的代码只会让人更讨厌维护。</li>
</ul></li>
</ul>

<h4><a class="anchor" id="2.2.3-代码的正确性" href="http://review.iauto.net/developrule/CodingRule#2.2.3-%E4%BB%A3%E7%A0%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7"><i class="fa fa-link"></i></a>2.2.3 代码的正确性</h4>

<p>虽然不是本规范的重点，但是对于常见的正确性问题也做了一些说明。举例来说，C编程中的一个经典错误可能是这样：
</p><pre class="highlight">  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 笔误！作者本意是判断c == 1
</span>      <span class="n">printf</span><span class="p">(</span><span class="s">"c is equal to 1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="p">}</span>
</pre>


<p>但是如果编程规范中规定，比较操作时，常量一定要放在左值，那代码可能变成：
</p><pre class="highlight">  <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">=</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 同样的笔误，但是会被编译器检测到
</span>      <span class="n">printf</span><span class="p">(</span><span class="s">"c is equal to 1</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="p">}</span>
</pre>


<p>一样的错误，不一样的命运！像这种实用的编程风格，一定要变成每个程序员固有的习惯！</p>

<h4><a class="anchor" id="2.2.4-代码的执行效率" href="http://review.iauto.net/developrule/CodingRule#2.2.4-%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87"><i class="fa fa-link"></i></a>2.2.4 代码的执行效率</h4>

<p>虽然很多人都知道i++和++i的不同，但是大部分新手还是习惯性的使用i++。殊不知，这两种写法会带来巨大的效率差异！本规范中涉及执行效率的内容，就是希望能够通过改变开发者一点点的编程习惯，来改善一定的代码执行效率。</p>

<h4><a class="anchor" id="2.2.5-提高开发效率" href="http://review.iauto.net/developrule/CodingRule#2.2.5-%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87"><i class="fa fa-link"></i></a>2.2.5 提高开发效率</h4>

<p>很多不规范的编程习惯甚至会影响到开发效率！比如说，很多不太注意的程序员，会在头文件中随意引用其他的头文件，这将会导致引用此头文件的cpp文件编译速度变慢，而且一旦某个头文件改变，可能会导致无数的cpp文件重编，这是对开发效率的巨大伤害！</p>

<h3><a class="anchor" id="2.3-编程规范指定上的考虑" href="http://review.iauto.net/developrule/CodingRule#2.3-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E6%8C%87%E5%AE%9A%E4%B8%8A%E7%9A%84%E8%80%83%E8%99%91"><i class="fa fa-link"></i></a>2.3 编程规范指定上的考虑</h3>

<p>本编程规范在制定时参考了：</p>

<ul>
<li>之前公司开发项目的编程经验</li>
<li>《高质量C/C++编程》</li>
<li>Google开发规范</li>
<li>当前流行的开源库，如Webkit/Chrome/Qt等</li>
</ul>

<h3><a class="anchor" id="2.4-阅读本规范需要注意的东西" href="http://review.iauto.net/developrule/CodingRule#2.4-%E9%98%85%E8%AF%BB%E6%9C%AC%E8%A7%84%E8%8C%83%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%9C%E8%A5%BF"><i class="fa fa-link"></i></a>2.4 阅读本规范需要注意的东西</h3>

<p>本文中规定的规范，适用于（但不限于）C/C++的编程。有特例的情形，会特别注明。</p>

<p>本文中规定的规范，大体上分为<code>[必须]</code>和<code>[推荐]</code>两部分。</p>

<table><thead>
<tr>
<th>标记</th>
<th>说明</th>
</tr>
</thead><tbody>
<tr>
<td><code>[必须]</code></td>
<td>表示在编码过程中必须共通遵守的项目</td>
</tr>
<tr>
<td><code>[推荐]</code></td>
<td>表示推荐项目，尽量遵守，在编码过程中不做强制要求</td>
</tr>
<tr>
<td><code>[例外]</code></td>
<td>为了方便编码，可以不遵守指定规范的的项目</td>
</tr>
</tbody></table>

<h2><a class="anchor" id="3.-文件规范" href="http://review.iauto.net/developrule/CodingRule#3.-%E6%96%87%E4%BB%B6%E8%A7%84%E8%8C%83"><i class="fa fa-link"></i></a>3. 文件规范</h2>

<h3><a class="anchor" id="3.1-文件命名" href="http://review.iauto.net/developrule/CodingRule#3.1-%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D"><i class="fa fa-link"></i></a>3.1 文件命名</h3>

<p>这里提到的文件主要分为两类：</p>

<ul>
<li>头文件：通常所说的扩展名是<code>.h</code>的文件</li>
<li>源文件：有C语言和C++语言之分

<ul>
<li>C语言的扩展名为<code>.c</code></li>
<li>C++语言的扩展名为<code>.cpp</code></li>
</ul></li>
</ul>

<h4><a class="anchor" id="3.1.1-基本文件命名规则" href="http://review.iauto.net/developrule/CodingRule#3.1.1-%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><i class="fa fa-link"></i></a>3.1.1 基本文件命名规则</h4>

<p>在文件名中只能使用下列ASCII字符，其他字符均不允许使用。<code>[必须]</code></p>

<ul>
<li>半角英文字母（a~z, A~Z）</li>
<li>数字（0~9）</li>
<li>分割字符：<code>_</code></li>
</ul>

<p>原则上一个Class对应一组<code>.h</code>头文件和<code>.cpp</code>源文件，文件名和Class名相同。<code>[推荐]</code></p>

<p><code>[例外]</code>如果一个头文件中有多个Class时，若是下列情况，可以作为例外。</p>

<ul>
<li>一个Class作为主Class，其他Class为其服务。（此时主Class作为文件名）

<ul>
<li>建议把其他Class定义在主Class内部作为嵌套Class。<code>[推荐]</code></li>
</ul></li>
<li>两个Class有紧密的联系（此种情形仅限于Event通知的定义，继承除外）</li>
</ul>

<p>判断的基准：这些Class必须有一个特点：其中一个被用到时，另外一个也会同时被用到。<code>[推荐]</code></p>

<h4><a class="anchor" id="3.1.2-扩展名" href="http://review.iauto.net/developrule/CodingRule#3.1.2-%E6%89%A9%E5%B1%95%E5%90%8D"><i class="fa fa-link"></i></a>3.1.2 扩展名</h4>

<p>扩展名必须全部使用小写字母。<code>[必须]</code></p>

<ul>
<li>头文件：

<ul>
<li>扩展名一律为<code>.h</code>。<code>[必须]</code></li>
</ul></li>
<li>源文件：

<ul>
<li>C的扩展名为<code>.c</code>。<code>[必须]</code></li>
<li>C++的扩展名为<code>.cpp</code>。<code>[必须]</code></li>
</ul></li>
</ul>

<h4><a class="anchor" id="3.1.3-文件名" href="http://review.iauto.net/developrule/CodingRule#3.1.3-%E6%96%87%E4%BB%B6%E5%90%8D"><i class="fa fa-link"></i></a>3.1.3 文件名</h4>

<p>文件名命名规范遵循下面的方式。<code>[推荐]</code></p>

<ul>
<li>含有Class的C++的文件名必须和Class名一致，大小写也和Class名一致。</li>
<li>其他文件命名采用单词首字母大写，单词连写的形式。例如，<code>Sample.h</code>, <code>SampleCode.h</code>, <code>SampleCode.cpp</code>。</li>
<li>实际上，在大型项目中组织代码，还经常要在有意义的文件名前，再加入文件的分类。比如，如果SampleCode.cpp属于Network模块，那文件名可能变为：<code>NetworkSampleCode.cpp</code>。</li>
<li>除了前缀，文件有可能会被加上后缀。比如要实现Semaphore功能，可以基于Linux的系统调用，也可以基于Posix的API，这两种实现共存在项目中的时候，可以根据后缀来区分，文件名可能变成这样： <code>SemaphoreLinux.cpp</code>, <code>SemaphorePosix.cpp</code>。</li>
</ul>

<h3><a class="anchor" id="3.2-文件内的排列顺序" href="http://review.iauto.net/developrule/CodingRule#3.2-%E6%96%87%E4%BB%B6%E5%86%85%E7%9A%84%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F"><i class="fa fa-link"></i></a>3.2 文件内的排列顺序</h3>

<h4><a class="anchor" id="3.2.1-头文件的排列顺序" href="http://review.iauto.net/developrule/CodingRule#3.2.1-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F"><i class="fa fa-link"></i></a>3.2.1 头文件的排列顺序</h4>

<p>头文件中按照下面的顺序进行排列。<code>[必须]</code></p>

<ol>
<li>文件开头注释（参考<a href="http://review.iauto.net/developrule/CodingRule#12.1.1.1-%E5%A4%B4%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A">12.1.1.1</a>）</li>
<li>头文件的包含保护宏（参考<a href="http://review.iauto.net/developrule/CodingRule#3.4-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%85%E5%90%AB%E4%BF%9D%E6%8A%A4">3.4</a>）</li>
<li>包含的头文件（参考<a href="http://review.iauto.net/developrule/CodingRule#3.3-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%A7%84%E8%8C%83">3.3</a>）</li>
<li>宏定义</li>
<li>常量</li>
<li>其他类型声明</li>
<li>C类型函数声明</li>
<li>类定义（参考<a href="http://review.iauto.net/developrule/CodingRule#9.1.4-%60class%60%E5%86%85%E7%9A%84%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F">9.1.4</a>）</li>
<li>文件结尾注释（参考<a href="http://review.iauto.net/developrule/CodingRule#12.1.1.1-%E5%A4%B4%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A">12.1.1.1</a>）</li>
</ol>

<h4><a class="anchor" id="3.2.2-C/C++源文件的排列顺序" href="http://review.iauto.net/developrule/CodingRule#3.2.2-C/C++%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F"><i class="fa fa-link"></i></a>3.2.2 C/C++源文件的排列顺序</h4>

<p>源文件中按照下面的顺序进行排列。<code>[必须]</code></p>

<ol>
<li>文件开始注释（参考<a href="http://review.iauto.net/developrule/CodingRule#12.1.1.2-%E6%BA%90%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A">12.1.1.2</a>）</li>
<li>包含的头文件（参考<a href="http://review.iauto.net/developrule/CodingRule#3.3-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%A7%84%E8%8C%83">3.3</a>）</li>
<li>静态常量</li>
<li>变量的定义</li>
<li>静态函数的声明/定义</li>
<li>类构造函数</li>
<li>类析构函数</li>
<li>其他</li>
<li>文件结尾注释（参考<a href="http://review.iauto.net/developrule/CodingRule#12.1.1.2-%E6%BA%90%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A">12.1.1.2</a>）</li>
</ol>

<h3><a class="anchor" id="3.3-头文件包含规范" href="http://review.iauto.net/developrule/CodingRule#3.3-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%A7%84%E8%8C%83"><i class="fa fa-link"></i></a>3.3 头文件包含规范</h3>

<h4><a class="anchor" id="3.3.1-头文件包含规则" href="http://review.iauto.net/developrule/CodingRule#3.3.1-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%A7%84%E5%88%99"><i class="fa fa-link"></i></a>3.3.1 头文件包含规则</h4>

<ul>
<li>使用<code>&lt;&gt;</code>来引用系统头文件。（参考<a href="http://review.iauto.net/developrule/CodingRule#3.3.2.1-%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6">3.3.2.1</a>）<code>[必须]</code></li>
<li>使用<code>&lt;&gt;</code>来引用外部头文件。（参考<a href="http://review.iauto.net/developrule/CodingRule#3.3.2.2-%E5%A4%96%E9%83%A8%E5%A4%B4%E6%96%87%E4%BB%B6">3.3.2.2</a>）<code>[推荐]</code></li>
<li>使用<code>""</code>来引用内部头文件。<code>[必须]</code></li>
</ul>

<p>例如，
</p><pre class="highlight"><span class="cp">#include &lt;stdlib.h&gt;
#include "other.h"
</span></pre>


<h4><a class="anchor" id="3.3.2-头文件的包含顺序" href="http://review.iauto.net/developrule/CodingRule#3.3.2-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%85%E5%90%AB%E9%A1%BA%E5%BA%8F"><i class="fa fa-link"></i></a>3.3.2 头文件的包含顺序</h4>

<p>头文件按照先系统头文件，再外部头文件，最后是内部头文件的形式进行包含。<code>[必须]</code></p>

<h5><a class="anchor" id="3.3.2.1-系统头文件" href="http://review.iauto.net/developrule/CodingRule#3.3.2.1-%E7%B3%BB%E7%BB%9F%E5%A4%B4%E6%96%87%E4%BB%B6"><i class="fa fa-link"></i></a>3.3.2.1 系统头文件</h5>

<p>所谓的“系统头文件”，一般包括：</p>

<ul>
<li>C库的头文件，如<code>&lt;stdio.h&gt;</code></li>
<li>操作系统相关的头文件，如 <code>&lt;sys/stat.h&gt;</code></li>
<li>标准库的头文件，如<code>&lt;vector&gt;</code></li>
<li>非标准库（第三方库）的头文件，如GLib的<code>&lt;glib.h&gt;</code></li>
</ul>

<p>引用系统头文件时，注意要按照上面的顺序。<code>[必须]</code></p>

<h5><a class="anchor" id="3.3.2.2-外部头文件" href="http://review.iauto.net/developrule/CodingRule#3.3.2.2-%E5%A4%96%E9%83%A8%E5%A4%B4%E6%96%87%E4%BB%B6"><i class="fa fa-link"></i></a>3.3.2.2 外部头文件</h5>

<p>外部头文件是指工程内其他模块提供的外部公开的头文件。</p>

<p>外部头文件要按照模块的逻辑层次，从低到高来引用。<code>[必须]</code></p>

<h5><a class="anchor" id="3.3.2.3-内部头文件" href="http://review.iauto.net/developrule/CodingRule#3.3.2.3-%E5%86%85%E9%83%A8%E5%A4%B4%E6%96%87%E4%BB%B6"><i class="fa fa-link"></i></a>3.3.2.3 内部头文件</h5>

<p>内部头文件是指模块内部的头文件，包含了提供给外部公开的头文件和非公开的头文件。</p>

<p>内部头文件也要按照模块的逻辑层次，从低到高来引用。<code>[必须]</code></p>

<h4><a class="anchor" id="3.3.3-不要包含无用的头文件" href="http://review.iauto.net/developrule/CodingRule#3.3.3-%E4%B8%8D%E8%A6%81%E5%8C%85%E5%90%AB%E6%97%A0%E7%94%A8%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><i class="fa fa-link"></i></a>3.3.3 不要包含无用的头文件</h4>

<p>不要包含无用的头文件。<code>[必须]</code></p>

<p>引用无用的头文件，会导致很多问题：</p>

<ul>
<li>大部分的头文件循环引用问题都是滥用头文件导致的</li>
<li>在某个cpp中引入大量的头文件，会导致编译速度变慢</li>
<li>某个头文件有修改，可能会导致项目中无数无关的cpp文件重新编译</li>
</ul>

<p>最容易发生滥用头文件的场合是：</p>

<ul>
<li>不知道该使用哪个头文件，就全部都包含进去</li>
<li>曾经使用了某个头文件里的东西，后来不用，但是没有删除</li>
</ul>

<h4><a class="anchor" id="3.3.4-包含头文件时使用相对路径" href="http://review.iauto.net/developrule/CodingRule#3.3.4-%E5%8C%85%E5%90%AB%E5%A4%B4%E6%96%87%E4%BB%B6%E6%97%B6%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><i class="fa fa-link"></i></a>3.3.4 包含头文件时使用相对路径</h4>

<p>在包含头文件时使用相对路径是很危险的行为。</p>

<ul>
<li>路径变更以后，很可能会引起编译错误</li>
<li>一些系统头文件的安装路径，在不同的系统中，甚至不同的版本上，都是不一样的，这会带来移植性问题</li>
</ul>

<p>在包含头文件时，禁止使用像下面一样的相对路径（含有<code>..</code>的路径）。<code>[必须]</code>
</p><pre class="highlight"><span class="cp">#include "../../folder/Sample.h"
</span></pre>


<p>如果公开头文件的目录有多级目录时，必需按照下面的方式包含。（参考<a href="http://review.iauto.net/developrule/NameRule">iAuto命名规范</a>）<code>[必须]</code>
</p><pre class="highlight"><span class="cp">#include "subfolder/Sample.h"
</span></pre>


<h4><a class="anchor" id="3.3.5-通过显示的类声明避免引入过多的头文件" href="http://review.iauto.net/developrule/CodingRule#3.3.5-%E9%80%9A%E8%BF%87%E6%98%BE%E7%A4%BA%E7%9A%84%E7%B1%BB%E5%A3%B0%E6%98%8E%E9%81%BF%E5%85%8D%E5%BC%95%E5%85%A5%E8%BF%87%E5%A4%9A%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><i class="fa fa-link"></i></a>3.3.5 通过显示的类声明避免引入过多的头文件</h4>

<p>通过显示的类声明避免引入过多的头文件。<code>[推荐]</code></p>

<p>在很多场合下，对头文件的引用可能只是为了使用其中的某个类型定义。比如ClassB.h用到ClassA.h头文件中定义的ClassA：
</p><pre class="highlight"><span class="c1">// ClassB.h
</span>
<span class="cp">#include “ClassA.h”
</span>
<span class="k">class</span> <span class="nc">ClassB</span> 
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="p">...</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">ClassA</span> <span class="o">*</span><span class="n">m_classA</span><span class="p">;</span>
<span class="p">};</span>
</pre>


<p>由于没有用到ClassA的具体结构，所以ClassB.h其实是没有必要包含ClassA.h，只要改成如下形式就可以避免：
</p><pre class="highlight"><span class="c1">// ClassB.h
</span>
<span class="k">class</span> <span class="nc">ClassA</span><span class="p">;</span> <span class="c1">// 使用声明ClassA替代包含ClassA.h
</span>
<span class="k">class</span> <span class="nc">ClassB</span> 
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="p">...</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">ClassA</span> <span class="o">*</span><span class="n">m_classA</span><span class="p">;</span>
<span class="p">};</span>
</pre>


<h3><a class="anchor" id="3.3.6-包含外部公开的头文件" href="http://review.iauto.net/developrule/CodingRule#3.3.6-%E5%8C%85%E5%90%AB%E5%A4%96%E9%83%A8%E5%85%AC%E5%BC%80%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><i class="fa fa-link"></i></a>3.3.6 包含外部公开的头文件</h3>

<p>包含外部头文件时，只能包含公开的头文件。禁止包含其他模块内部非公开的头文件。<code>[必须]</code></p>

<h3><a class="anchor" id="3.4-头文件的包含保护" href="http://review.iauto.net/developrule/CodingRule#3.4-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%85%E5%90%AB%E4%BF%9D%E6%8A%A4"><i class="fa fa-link"></i></a>3.4 头文件的包含保护</h3>

<ul>
<li>在头文件定义并使用包含保护宏。<code>[必须]</code></li>
</ul>

<pre class="highlight"><span class="cp">#ifndef SAMPLE_H  // 多重包含保护
#define SAMPLE_H  // 包含保护宏定义
</span><span class="p">...</span>
<span class="cp">#endif </span><span class="cm">/* SAMPLE_H */</span><span class="cp">
</span></pre>


<ul>
<li>第三方开发库的头文件里可能没有使用包含保护，包含这些头文件时，使用扩展的包含保护。<code>[推荐]</code></li>
</ul>

<pre class="highlight"><span class="cp">#ifndef MATHLIB_H
#   include &lt;mathlib.h&gt;     // 第三方库头文件
#   define MATHLIB_H        // 包含保护宏定义
#endif </span><span class="cm">/* MATHLIB_H */</span><span class="cp">
</span></pre>


<ul>
<li>如果可以确定第三方库的头文件中已经使用了包含保护，不需要再定义包含保护，直接包含头文件。<code>[推荐]</code></li>
</ul>

<pre class="highlight"><span class="cp">#include &lt;QWidget&gt;          // Qt库头文件
</span></pre>


<h4><a class="anchor" id="3.4.1-包含保护宏的定义" href="http://review.iauto.net/developrule/CodingRule#3.4.1-%E5%8C%85%E5%90%AB%E4%BF%9D%E6%8A%A4%E5%AE%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><i class="fa fa-link"></i></a>3.4.1 包含保护宏的定义</h4>

<p>头文件中需要在开头的位置定义包含保护宏，包含保护宏参照以下形式（假定头文件为Sample.h）。</p>

<p><code>SAMPLE_H</code></p>

<p>即：文件名所有字母大写，<code>.h</code>变为<code>_H</code>。<code>[必须]</code>
</p><pre class="highlight"><span class="cp">#define SAMPLE_H
</span></pre>


<p>如果使用第三方头文件，需要我们定义包含保护宏时，遵守下面的规则。[推荐]</p>

<ul>
<li>所有英文字母大写</li>
<li>文件名中英文字母、以及数字以外的字符，都变为"_"。</li>
</ul>

<p>例如，头文件server-protocol.h的保护宏定义如下。
</p><pre class="highlight"><span class="cp">#define SERVER_PROTOCOL_H
</span></pre>


<h4><a class="anchor" id="3.4.2-头文件中的包含保护" href="http://review.iauto.net/developrule/CodingRule#3.4.2-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%8C%85%E5%90%AB%E4%BF%9D%E6%8A%A4"><i class="fa fa-link"></i></a>3.4.2 头文件中的包含保护</h4>

<p>下面是头文件中使用包含保护的例子。
</p><pre class="highlight"><span class="cp">#ifndef SAMPLE_H            // 多重包含保护
#define SAMPLE_H            // 包含保护宏的定义
</span>
<span class="cp">#include &lt;stdlib.h&gt;         // 标准库头文件
</span>
<span class="cp">#ifndef MATHLIB_H
#   include &lt;mathlib.h&gt;     // 第三方库头文件
#   define MATHLIB_H
#endif </span><span class="cm">/* MATHLIB_H */</span><span class="cp">
</span>
<span class="cp">#include &lt;QWidget&gt;          // Qt库头文件
</span>
<span class="cp">#include “Log.h”            // 工程内头文件
</span>
<span class="p">...</span>

<span class="cp">#endif </span><span class="cm">/* SAMPLE_H */</span><span class="cp">
</span><span class="cm">/* EOF */</span>
</pre>


<h4><a class="anchor" id="3.4.3-源文件中的包含保护" href="http://review.iauto.net/developrule/CodingRule#3.4.3-%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%8C%85%E5%90%AB%E4%BF%9D%E6%8A%A4"><i class="fa fa-link"></i></a>3.4.3 源文件中的包含保护</h4>

<p>下面是源文件中使用包含保护的例子。
</p><pre class="highlight"><span class="cp">#include &lt;stdlib.h&gt;         // 标准库头文件
</span>
<span class="cp">#ifndef MATHLIB_H
#   include &lt;mathlib.h&gt;     // 第三方库头文件
#   define MATHLIB_H
#endif </span><span class="cm">/* MATHLIB_H */</span><span class="cp">
</span>
<span class="cp">#include &lt;QWidget&gt;          // Qt库头文件
</span>
<span class="cp">#include “Log.h”            // 工程内头文件
</span>
<span class="p">...</span>
</pre>


<h3><a class="anchor" id="3.5-注明C++头文件" href="http://review.iauto.net/developrule/CodingRule#3.5-%E6%B3%A8%E6%98%8EC++%E5%A4%B4%E6%96%87%E4%BB%B6"><i class="fa fa-link"></i></a>3.5 注明C++头文件</h3>

<p>如果是C++的头文件，在文件中使用下面的方式注明。<code>[必须]</code>
</p><pre class="highlight"><span class="cp">#ifndef __cplusplus
#   error ERROR: This file requires C++ compilation (use a .cpp suffix)
#endif
</span></pre>


<h3><a class="anchor" id="3.6-头文件中的其他规则" href="http://review.iauto.net/developrule/CodingRule#3.6-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E8%A7%84%E5%88%99"><i class="fa fa-link"></i></a>3.6 头文件中的其他规则</h3>

<h4><a class="anchor" id="3.6.1-不要在头文件中定义变量" href="http://review.iauto.net/developrule/CodingRule#3.6.1-%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><i class="fa fa-link"></i></a>3.6.1 不要在头文件中定义变量</h4>

<p>在头文件中定义变量，会导致变量生成多份拷贝，所以一定要避免。<code>[必须]</code></p>

<p>C/C++中，所有的“定义”（definition）是相对“声明”(declaration)而言的，区分变量是“定义”和“声明”的唯一标准是是否会造成内存使用。
</p><pre class="highlight"><span class="c1">// 声明的例子
</span><span class="k">extern</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Type</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="c1">// 定义的例子
</span><span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="n">Type</span> <span class="n">t</span><span class="p">;</span>
</pre>


<h4><a class="anchor" id="3.6.2-不要在头文件中使用using-namespace" href="http://review.iauto.net/developrule/CodingRule#3.6.2-%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E4%BD%BF%E7%94%A8using-namespace"><i class="fa fa-link"></i></a>3.6.2 不要在头文件中使用<code>using namespace</code></h4>

<p>在头文件中禁止使用<code>using namespace xxx</code>。<code>[必须]</code></p>

<p>使用<code>namespace</code>的目的就是为了避免污染全局命名空间。但是代码中如果用了<code>using namespace xxx</code>，那<code>namespace</code>本来的意义就没了，所以<code>using namespace</code>的操作尽量慎用。</p>

<p>如果用在头文件中，因为无法保证这个头文件再会被谁使用，这就造成了namespace 完全暴露给了所有包含了此头文件的cpp，这会造成严重的命名空间污染。</p>

<p>在<code>cpp</code>文件中，如果保证不会有全局命名空间污染的问题，那么可以使用<code>using namespace xxx</code>。</p>

<h2><a class="anchor" id="4.-缩进与换行" href="http://review.iauto.net/developrule/CodingRule#4.-%E7%BC%A9%E8%BF%9B%E4%B8%8E%E6%8D%A2%E8%A1%8C"><i class="fa fa-link"></i></a>4. 缩进与换行</h2>

<h3><a class="anchor" id="4.1-缩进的格式" href="http://review.iauto.net/developrule/CodingRule#4.1-%E7%BC%A9%E8%BF%9B%E7%9A%84%E6%A0%BC%E5%BC%8F"><i class="fa fa-link"></i></a>4.1 缩进的格式</h3>

<p>由于很多不同的编辑器处理Tab和空格的方式不一样，会导致排版的混乱，因此要求以4个空格取代Tab。</p>

<ul>
<li>在编码中禁止使用Tab，使用空格取代。<code>[必须]</code></li>
<li>使用4个空格进行缩进。<code>[必须]</code></li>
</ul>

<h3><a class="anchor" id="4.2-避免长行" href="http://review.iauto.net/developrule/CodingRule#4.2-%E9%81%BF%E5%85%8D%E9%95%BF%E8%A1%8C"><i class="fa fa-link"></i></a>4.2 避免长行</h3>

<p>如果代码行过长，也会影响代码的可读性，所以有必要限制每行的最大字符数。</p>

<p>建议每个代码行不要超过100个字符。<code>[推荐]</code></p>

<h3><a class="anchor" id="4.3-函数的换行" href="http://review.iauto.net/developrule/CodingRule#4.3-%E5%87%BD%E6%95%B0%E7%9A%84%E6%8D%A2%E8%A1%8C"><i class="fa fa-link"></i></a>4.3 函数的换行</h3>

<h4><a class="anchor" id="4.3.1-函数中的换行要以参数为起点" href="http://review.iauto.net/developrule/CodingRule#4.3.1-%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C%E8%A6%81%E4%BB%A5%E5%8F%82%E6%95%B0%E4%B8%BA%E8%B5%B7%E7%82%B9"><i class="fa fa-link"></i></a>4.3.1 函数中的换行要以参数为起点</h4>

<p>函数中的换行必须要以参数为起点。<code>[必须]</code></p>

<p>正确的例子：
</p><pre class="highlight"><span class="kt">unsigned</span> <span class="n">longSomeClass</span><span class="o">::</span><span class="n">hook</span><span class="p">(</span><span class="kt">int</span> <span class="n">anArg</span><span class="p">,</span> <span class="n">Object</span> <span class="n">anotherArg</span><span class="p">,</span>
    <span class="n">String</span> <span class="n">yetAnotherArg</span><span class="p">,</span> <span class="n">Object</span> <span class="n">andStillAnother</span><span class="p">);</span>
</pre>


<p>不合适的例子：（声明/定义时从参数中间断行）
</p><pre class="highlight"><span class="kt">unsigned</span> <span class="n">longSomeClass</span><span class="o">::</span><span class="n">hook</span><span class="p">(</span><span class="kt">int</span> <span class="n">anArg</span><span class="p">,</span> <span class="n">Object</span>
    <span class="n">anotherArg</span><span class="p">,</span> <span class="n">String</span> <span class="n">yetAnotherArg</span><span class="p">,</span> <span class="n">Object</span> <span class="n">andStillAnother</span><span class="p">);</span>
</pre>


<p>又一个不合适的例子：(调用函数从某个参数中间断行)
</p><pre class="highlight">  <span class="n">instance</span><span class="p">.</span><span class="n">hook</span><span class="p">(</span><span class="n">getBigness</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span>
      <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
      <span class="n">A</span><span class="p">,</span> <span class="s">"xxx"</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
</pre>


<p>一种正确的写法：
</p><pre class="highlight">  <span class="n">instance</span><span class="p">.</span><span class="n">hook</span><span class="p">(</span><span class="n">getBigness</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span>
                <span class="n">A</span><span class="p">,</span> <span class="s">"xxx"</span><span class="p">,</span> <span class="n">B</span><span class="p">);</span>
</pre>


<h4><a class="anchor" id="4.3.2-新行的缩进方式" href="http://review.iauto.net/developrule/CodingRule#4.3.2-%E6%96%B0%E8%A1%8C%E7%9A%84%E7%BC%A9%E8%BF%9B%E6%96%B9%E5%BC%8F"><i class="fa fa-link"></i></a>4.3.2 新行的缩进方式</h4>

<p>新行可以有两种缩进方式：<code>[必须]</code></p>

<ul>
<li>相对首行缩进4个空格</li>
<li>新行从首行左括号处开始缩进</li>
</ul>

<p>选择缩进方式的原则是（以代码行不超过100个字符为基准）：<code>[推荐]</code></p>

<ul>
<li>如果函数名比较短，左括号位置比较靠前，建议从对齐左括号的地方开始缩进。</li>
<li>如果函数名比较长，左括号位置比较靠后，建议以相对首行4个字符的方式开始缩进。</li>
</ul>

<p>缩进换行的例子：</p>

<ul>
<li>函数名比较短，以对齐左括号的方式换行：</li>
</ul>

<pre class="highlight"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xxx</span><span class="p">(</span><span class="kt">int</span> <span class="n">anArg</span><span class="p">,</span> <span class="n">Object</span> <span class="n">anotherArg</span><span class="p">,</span>
                 <span class="n">String</span> <span class="n">yetAnotherArg</span><span class="p">,</span> <span class="n">Object</span> <span class="n">andStillAnother</span><span class="p">);</span>
</pre>


<ul>
<li>函数名比较长，以缩进4个空格的方式换行：</li>
</ul>

<pre class="highlight"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">longSomeClass</span><span class="o">::</span><span class="n">hook</span><span class="p">(</span><span class="kt">int</span> <span class="n">anArg</span><span class="p">,</span> <span class="n">Object</span> <span class="n">anotherArg</span><span class="p">,</span>
    <span class="n">String</span> <span class="n">yetAnotherArg</span><span class="p">,</span> <span class="n">Object</span> <span class="n">andStillAnother</span><span class="p">);</span>
</pre>


<ul>
<li>无序的缩进换行，应该禁止：</li>
</ul>

<pre class="highlight"><span class="kt">unsigned</span> <span class="n">longSomeClass</span><span class="o">::</span><span class="n">hook</span><span class="p">(</span><span class="kt">int</span> <span class="n">anArg</span><span class="p">,</span> <span class="n">Object</span> <span class="n">anotherArg</span><span class="p">,</span>
                <span class="n">String</span> <span class="n">yetAnotherArg</span><span class="p">,</span> <span class="n">Object</span> <span class="n">andStillAnother</span><span class="p">);</span>
</pre>


<h4><a class="anchor" id="4.3.3-函数体的换行" href="http://review.iauto.net/developrule/CodingRule#4.3.3-%E5%87%BD%E6%95%B0%E4%BD%93%E7%9A%84%E6%8D%A2%E8%A1%8C"><i class="fa fa-link"></i></a>4.3.3 函数体的换行</h4>

<p>函数体定义需要遵循下面的规范：</p>

<ul>
<li><code>{</code>和<code>}</code>分别单独占一行。<code>[必须]</code></li>
</ul>

<pre class="highlight"><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre>


<p><code>[例外]</code>如果是定义在类定义中的空实现，可以不遵守上述规范。此时，需将<code>{</code>和<code>}</code>写在一起，并放置在函数后面，和<code>)</code>之间留一个空格。<code>[必须]</code></p>

<p>通常会在空实现的虚析构、callback类中使用。
</p><pre class="highlight"><span class="k">class</span> <span class="nc">SampleCallback</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">SampleCallback</span><span class="p">()</span> <span class="p">{}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">callback1</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">callback2</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
</pre>


<p>不过，有初始化列表的构造函数，则{和}分别单独占一行！<code>[必须]</code></p>

<blockquote>
<p>因为构造函数/析构函数（尤其是类定义有基类或者类成员变量）内联时会有隐含的动作，强烈建议把构造函数/析构函数放在cpp中实现。<code>[推荐]</code></p>
</blockquote>

<pre class="highlight"><span class="k">class</span> <span class="nc">Smaple</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Sample</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">m_width</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">,</span> <span class="n">m_height</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="p">...</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int32_t</span>      <span class="n">m_width</span><span class="p">;</span>
    <span class="kt">int32_t</span>      <span class="n">m_height</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>不宜使用内联构造函数的例子。
</p><pre class="highlight"><span class="k">class</span> <span class="nc">Smaple</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Sample</span><span class="p">()</span>             <span class="c1">// 不宜！因为有隐含的动作，强烈建议在cpp中实现。
</span>        <span class="o">:</span> <span class="n">Base</span><span class="p">()</span>
        <span class="p">,</span> <span class="n">m_name</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="p">...</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span>      <span class="n">m_name</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<ul>
<li>一行中最多有一条语句。<code>[必须]</code></li>
</ul>

<pre class="highlight">  <span class="n">doSomething</span><span class="p">();</span> <span class="n">doAnotherThing</span><span class="p">();</span> <span class="c1">// 不可以！！！一行中最多有一条语句。
</span></pre>


<ul>
<li>函数体内的内容（<code>{</code>和<code>}</code>之间的内容）整体缩进4个空格。<code>[必须]</code></li>
</ul>

<pre class="highlight"><span class="kt">void</span> <span class="nf">doSomething</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 函数体内的内容整体缩进4个空格
</span>    <span class="n">statement1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">statement2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">...</span>
<span class="p">}</span>
</pre>


<h3><a class="anchor" id="4.4-表达式中的换行" href="http://review.iauto.net/developrule/CodingRule#4.4-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C"><i class="fa fa-link"></i></a>4.4 表达式中的换行</h3>

<h4><a class="anchor" id="4.4.1-条件表达式中的换行" href="http://review.iauto.net/developrule/CodingRule#4.4.1-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C"><i class="fa fa-link"></i></a>4.4.1 条件表达式中的换行</h4>

<p>条件表达式中如果出现较长的表达式，需要进行换行时，按照下面规则换行。</p>

<ul>
<li>以二元逻辑操作符为起点进行换行。<code>[必须]</code></li>
<li>新行相对缩进4个空格。<code>[必须]</code></li>
</ul>

<p>正确的例子：
</p><pre class="highlight">  <span class="k">if</span> <span class="p">((</span><span class="n">condition1</span> <span class="o">&amp;&amp;</span> <span class="n">condition2</span><span class="p">)</span>
      <span class="o">||</span> <span class="p">(</span><span class="n">condition3</span> <span class="o">&amp;&amp;</span> <span class="n">condition4</span><span class="p">)</span>
      <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">condition5</span> <span class="o">&amp;&amp;</span> <span class="n">condition6</span><span class="p">)))</span> <span class="p">{</span>
      <span class="n">doSomethingAboutIt</span><span class="p">();</span>
  <span class="p">}</span>
</pre>


<h4><a class="anchor" id="4.4.2-含运算符的赋值语句的换行" href="http://review.iauto.net/developrule/CodingRule#4.4.2-%E5%90%AB%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%8D%A2%E8%A1%8C"><i class="fa fa-link"></i></a>4.4.2 含运算符的赋值语句的换行</h4>

<p>赋值语句中如果出现较长的运算符表达式，需要进行换行时，按照下面规则换行。</p>

<ul>
<li>以运算符为起点进行换行。<code>[必须]</code></li>
<li>新行可以采用下面两种缩进方式。<code>[必须]</code>

<ul>
<li>新行跟<code>=</code>后第一个操作数对齐</li>
<li>新行缩进4个空格</li>
</ul></li>
</ul>

<p>正确的例子：
</p><pre class="highlight">  <span class="n">Name1</span> <span class="o">=</span> <span class="n">longName2</span> <span class="o">*</span> <span class="p">(</span><span class="n">longName3</span> <span class="o">+</span> <span class="n">longName4</span> <span class="o">-</span> <span class="n">longName5</span><span class="p">)</span>
          <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">longName6</span><span class="p">;</span>

  <span class="c1">// 换行后新行内容过长，缩进4个空格
</span>  <span class="n">longName1</span> <span class="o">=</span> <span class="n">longName2</span> <span class="o">*</span> <span class="p">(</span><span class="n">longName3</span> <span class="o">+</span> <span class="n">longName4</span> <span class="o">-</span> <span class="n">longName5</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">longName6</span> <span class="o">*</span> <span class="p">(</span><span class="n">longName7</span> <span class="o">+</span> <span class="n">longName8</span> <span class="o">+</span> <span class="n">longName9</span><span class="p">)</span> <span class="o">+</span> <span class="n">longName10</span> <span class="o">-</span> <span class="n">longName11</span><span class="p">;</span>

  <span class="c1">// 也可以多次换行
</span>  <span class="n">longName1</span> <span class="o">=</span> <span class="n">longName2</span> <span class="o">*</span> <span class="p">(</span><span class="n">longName3</span> <span class="o">+</span> <span class="n">longName4</span> <span class="o">-</span> <span class="n">longName5</span><span class="p">)</span>
              <span class="o">+</span> <span class="n">longName6</span> <span class="o">*</span> <span class="p">(</span><span class="n">longName7</span> <span class="o">+</span> <span class="n">longName8</span> <span class="o">+</span> <span class="n">longName9</span><span class="p">)</span>
              <span class="o">+</span> <span class="n">longName10</span> <span class="o">-</span> <span class="n">longName11</span><span class="p">;</span>
</pre>


<p>如果新行过长（比如超过100个字符），采用缩进4个空格的方式。<code>[推荐]</code>  </p>

<h3><a class="anchor" id="4.4.3-三元操作中的换行" href="http://review.iauto.net/developrule/CodingRule#4.4.3-%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C"><i class="fa fa-link"></i></a>4.4.3 三元操作中的换行</h3>

<p>三元操作<code>?:</code>中如果出现较长的表达式，需要进行换行时，按照下面规则换行。</p>

<ul>
<li>以操作符为起点进行换行。<code>[必须]</code></li>
<li>新行可以采用下面两种缩进方式。<code>[必须]</code>

<ul>
<li><code>:</code>前换行，新行跟<code>?</code>对齐</li>
<li><code>?</code>前换行，新行相对于三元操作中第一个表达式的开始位置缩进4个空格</li>
</ul></li>
</ul>

<pre class="highlight">  <span class="c1">// 三元操作符换行例1
</span>  <span class="n">longVariableName</span> <span class="o">=</span> <span class="n">longExpression</span> <span class="o">?</span> <span class="n">Expression1</span>
                                    <span class="o">:</span> <span class="n">Expression2</span>
</pre>

<pre class="highlight">  <span class="c1">// 三元操作符换行例2
</span>  <span class="n">longVariableName</span> <span class="o">=</span> <span class="n">longExpression</span>
                         <span class="o">?</span> <span class="n">Expression1</span> <span class="o">:</span> <span class="n">Expression2</span>
</pre>

<pre class="highlight">  <span class="c1">// 三元操作符换行例3
</span>  <span class="n">longVariableName</span> <span class="o">=</span> <span class="n">longExpression</span>
                         <span class="o">?</span> <span class="n">longExpression1</span>
                         <span class="o">:</span> <span class="n">longExpression2</span>
</pre>


<h3><a class="anchor" id="4.5-含有成员的定义中的换行" href="http://review.iauto.net/developrule/CodingRule#4.5-%E5%90%AB%E6%9C%89%E6%88%90%E5%91%98%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C"><i class="fa fa-link"></i></a>4.5 含有成员的定义中的换行</h3>

<p>像<code>struct</code>，<code>enum</code>，<code>union</code>，<code>class</code>等含有成员的定义，需要遵循下面的规范。<code>[必须]</code></p>

<ul>
<li><code>{</code>单独占一行</li>
<li><code>}</code>和<code>;</code>写在一起，并单独占一行</li>
<li>每个成员单独占一行</li>
<li>定义的内容（<code>{</code>和<code>}</code>之间的内容）整体缩进4个空格</li>
<li>类定义中的<code>public/protected/private</code>修饰符不要缩进（跟类定义开始位置对齐）</li>
</ul>

<p>定义的例子：
</p><pre class="highlight"><span class="k">enum</span> <span class="n">MyEnumeration</span>
<span class="p">{</span>
    <span class="n">EnumValue1</span><span class="p">,</span>
    <span class="n">EnumValue2</span><span class="p">,</span>
    <span class="p">...</span>
<span class="p">};</span> <span class="c1">// ↓ MyEnumeration和MyStruct定义之间用空行分开。
</span>
<span class="k">struct</span> <span class="n">MyStruct</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span>   <span class="n">name</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">MyUnion</span>
<span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span>   <span class="n">addr</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">intValue</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MyClass</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">MyClass</span><span class="p">();</span>
    <span class="o">~</span><span class="n">MyClass</span><span class="p">();</span>

    <span class="kt">int32_t</span> <span class="n">width</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">setWidth</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">value</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int32_t</span> <span class="n">m_width</span><span class="p">;</span>
<span class="p">};</span>
</pre>


<p>如果使用C类型的<code>struct</code>，<code>enum</code>，<code>union</code>（有typedef），为了遵守上面的规范，可以写成下面的形式。
</p><pre class="highlight"><span class="k">enum</span> <span class="n">tagMyEnumeration</span>
<span class="p">{</span>
    <span class="n">EnumValue1</span><span class="p">,</span>
    <span class="n">EnumValue2</span><span class="p">,</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="n">tagMyEnumeration</span> <span class="n">MyEnumeration</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">tagMyStruct</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span>   <span class="n">name</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tagMyStruct</span> <span class="n">MyStruct</span><span class="p">;</span>

<span class="k">union</span> <span class="n">tagMyUnion</span>
<span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span>   <span class="n">addr</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">intValue</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">tagMyUnion</span> <span class="n">MyUnion</span><span class="p">;</span>

</pre>


<h3><a class="anchor" id="4.6-构造函数的初始化列表中的换行" href="http://review.iauto.net/developrule/CodingRule#4.6-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C"><i class="fa fa-link"></i></a>4.6 构造函数的初始化列表中的换行</h3>

<p>构造函数中初始化列表需要遵循下面的规范。<code>[必须]</code></p>

<ul>
<li>每个初始化（基类/成员变量）单独占一行</li>
<li>每个初始化行，相对于构造函数缩进4个空格</li>
</ul>

<p>构造函数初始化列表的写法。<code>[推荐]</code>
</p><pre class="highlight"><span class="n">Sample</span><span class="o">::</span><span class="n">Sample</span><span class="p">()</span>
    <span class="o">:</span> <span class="n">Base</span><span class="p">()</span>
    <span class="p">,</span> <span class="n">m_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre>


<p>也可以写成：
</p><pre class="highlight"><span class="n">Sample</span><span class="o">::</span><span class="n">Sample</span><span class="p">()</span> <span class="o">:</span>
    <span class="n">Base</span><span class="p">(),</span>
    <span class="n">m_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre>


<h3><a class="anchor" id="4.7-位域定义中的换行" href="http://review.iauto.net/developrule/CodingRule#4.7-%E4%BD%8D%E5%9F%9F%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C"><i class="fa fa-link"></i></a>4.7 位域定义中的换行</h3>

<p>位域定义中<code>:</code>操作符和操作数必须位于同一行，禁止换行。<code>[必须]</code></p>

<p>参考<a href="http://review.iauto.net/developrule/CodingRule#5.5.9.3-%E4%BD%8D%E5%9F%9F%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC">5.5.9.3</a>中的例子。</p>

<h3><a class="anchor" id="4.8-namespace中的换行" href="http://review.iauto.net/developrule/CodingRule#4.8-namespace%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C"><i class="fa fa-link"></i></a>4.8 <code>namespace</code>中的换行</h3>

<p><code>namespace</code>的定义，需要遵循下面的规范。<code>[必须]</code></p>

<ul>
<li><code>{</code>和<code>}</code>各单独占一行</li>
<li>每个成员单独占一行</li>
<li>定义的内容（<code>{</code>和<code>}</code>之间的内容）整体缩进4个空格</li>
</ul>

<p>定义的例子：
</p><pre class="highlight"><span class="k">namespace</span> <span class="n">mynamespace</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">MyClass</span>
    <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">class</span> <span class="nc">NestedClass</span>
        <span class="p">{</span>
        <span class="k">public</span><span class="o">:</span>
            <span class="p">...</span>

        <span class="k">private</span><span class="o">:</span>
            <span class="p">...</span>
        <span class="p">}</span>
        <span class="p">...</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="p">...</span>
    <span class="p">};</span>

    <span class="p">...</span>
<span class="p">}</span> <span class="c1">// end of namespace mynamespace
</span></pre>


<p><code>[例外]</code>如果有多重<code>namespace</code>的嵌套，为了避免过多缩进，嵌套的<code>namespace</code>不用缩进。<code>[必须]</code></p>

<p>例如，
</p><pre class="highlight"><span class="k">namespace</span> <span class="n">primernamespace</span>
<span class="p">{</span>
<span class="n">namesapce</span> <span class="n">nestednamesapce</span> <span class="c1">// primernamespace.nestednamesapce
</span><span class="p">{</span>
    <span class="k">class</span> <span class="nc">MyClass</span>
    <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">};</span>

    <span class="p">...</span>

<span class="p">}</span> <span class="c1">// end of namesapce nestednamesapce
</span>
    <span class="p">...</span>

<span class="p">}</span> <span class="c1">// end of namesapce primernamespace
</span></pre>


<h2><a class="anchor" id="5.-空行与空格" href="http://review.iauto.net/developrule/CodingRule#5.-%E7%A9%BA%E8%A1%8C%E4%B8%8E%E7%A9%BA%E6%A0%BC"><i class="fa fa-link"></i></a>5. 空行与空格</h2>

<p>代码中合适的空格与空行能显著的提升代码可读性，也是影响到代码质量的关键因素之一。</p>

<h3><a class="anchor" id="5.1-用空行对代码“分区”" href="http://review.iauto.net/developrule/CodingRule#5.1-%E7%94%A8%E7%A9%BA%E8%A1%8C%E5%AF%B9%E4%BB%A3%E7%A0%81%E2%80%9C%E5%88%86%E5%8C%BA%E2%80%9D"><i class="fa fa-link"></i></a>5.1 用空行对代码“分区”</h3>

<p>代码中有很多区域，比如头文件中，可能会有对其他头文件的引用，有宏定义，也有类定义等，使用空行可以很自然的把这些区域给隔离开来。<code>[推荐]</code>
</p><pre class="highlight"><span class="c1">// 第一分区
</span><span class="cp">#ifndef SAMPLE_H
#define SAMPLE_H
</span>
<span class="c1">// 第二分区，头文件引用区
</span><span class="cp">#include &lt;stdlib.h&gt;
</span>
<span class="c1">// 第三分区，宏定义区
</span><span class="cp">#define MAX_COUNT 10
</span>
<span class="c1">// 第四分区，相关类声明区
</span><span class="k">class</span> <span class="nc">other</span><span class="p">;</span>

<span class="c1">// 第五分区，类定义区
</span><span class="k">class</span> <span class="nc">MyWidget</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// 第六分区
</span><span class="cp">#endif </span><span class="cm">/* SAMPLE_H */</span><span class="cp">
</span><span class="cm">/* EOF */</span>
</pre>


<h3><a class="anchor" id="5.2-用空行对代码“分组”" href="http://review.iauto.net/developrule/CodingRule#5.2-%E7%94%A8%E7%A9%BA%E8%A1%8C%E5%AF%B9%E4%BB%A3%E7%A0%81%E2%80%9C%E5%88%86%E7%BB%84%E2%80%9D"><i class="fa fa-link"></i></a>5.2 用空行对代码“分组”</h3>

<p>并不是每个区域前后分别只要一个空行就行了，在比较大的区域内，还需要根据一定的情况，用空行把代码分成“组”。以下介绍一些分组的基本原则。</p>

<h4><a class="anchor" id="5.2.1-根据头文件类型的不同分组" href="http://review.iauto.net/developrule/CodingRule#5.2.1-%E6%A0%B9%E6%8D%AE%E5%A4%B4%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%8D%E5%90%8C%E5%88%86%E7%BB%84"><i class="fa fa-link"></i></a>5.2.1 根据头文件类型的不同分组</h4>

<p><a href="http://review.iauto.net/developrule/CodingRule#3.3-%E5%A4%B4%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%A7%84%E8%8C%83">3.3</a>中提到了头文件几个类型。如果代码中需要引用大量的头文件，可以考虑根据头文件的不同类型进行分组。<code>[推荐]</code></p>

<h4><a class="anchor" id="5.2.2-根据功能分组" href="http://review.iauto.net/developrule/CodingRule#5.2.2-%E6%A0%B9%E6%8D%AE%E5%8A%9F%E8%83%BD%E5%88%86%E7%BB%84"><i class="fa fa-link"></i></a>5.2.2 根据功能分组</h4>

<p>在同一个区域内，最好能根据功能块进行分组。比如，</p>

<ul>
<li>在函数声明区域，可以把有联系的函数声明放在一起，用空行与其他部分隔开。<code>[推荐]</code></li>
<li>在宏定义区域，把实现相关的宏定义写在一起，用空行与其他部分隔开。<code>[推荐]</code></li>
</ul>

<p>下面几个函数声明，分别涉及到文件操作和文件系统操作，可以用空行分隔：
</p><pre class="highlight"><span class="c1">// 文件系统操作相关的函数
</span><span class="kt">int</span> <span class="n">PFA_remove</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">inPath</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">PFA_rename</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">oldname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newname</span><span class="p">);</span>

<span class="c1">// 文件操作相关的函数
</span><span class="kt">int</span> <span class="n">PFA_open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">int</span> <span class="n">PFA_close</span><span class="p">(</span><span class="kt">int</span> <span class="n">fp</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">PFA_read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="n">PFA_write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
</pre>


<p>下面的四个宏定义分别实现了两个不同的功能，可以用空行分隔：
</p><pre class="highlight"><span class="cp">#define WSTR__(x) L ## x
#define WSTR(x) WSTR__(x)
</span>
<span class="cp">#define M2WSTR(x) WSTR(#x)
#define M2STR(x) #x
</span></pre>


<h4><a class="anchor" id="5.2.3-类型定义" href="http://review.iauto.net/developrule/CodingRule#5.2.3-%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><i class="fa fa-link"></i></a>5.2.3 类型定义</h4>

<p><code>struct</code>，<code>union</code>，<code>enum</code>，<code>class</code>类型定义后应该用空行隔开。（参考<a href="http://review.iauto.net/developrule/CodingRule#4.5-%E5%90%AB%E6%9C%89%E6%88%90%E5%91%98%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C">4.5</a>中的例子）<code>[必须]</code></p>

<h4><a class="anchor" id="5.2.4-函数定义" href="http://review.iauto.net/developrule/CodingRule#5.2.4-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><i class="fa fa-link"></i></a>5.2.4 函数定义</h4>

<p>函数定义后，应该用空行隔开。<code>[必须]</code></p>

<pre class="highlight"><span class="c1">// method1概要
</span><span class="kt">void</span> <span class="nf">method1</span><span class="p">()</span>
<span class="p">{</span>
     <span class="p">...</span>
<span class="p">}</span> <span class="c1">// ↓ method1()和method2()之间用空行隔开。
</span>
<span class="c1">// method2概要
</span><span class="kt">void</span> <span class="nf">method2</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre>


<h3><a class="anchor" id="5.3-用空行分隔逻辑块" href="http://review.iauto.net/developrule/CodingRule#5.3-%E7%94%A8%E7%A9%BA%E8%A1%8C%E5%88%86%E9%9A%94%E9%80%BB%E8%BE%91%E5%9D%97"><i class="fa fa-link"></i></a>5.3 用空行分隔逻辑块</h3>

<p>在一个函数内部，也要根据逻辑的不同，用空行分隔代码，增加代码可读性。<code>[推荐]</code></p>

<p>以下是一个典型的函数内部实现的例子：
</p><pre class="highlight"><span class="c1">// getAt概要
</span><span class="n">BookmarkInfo</span><span class="o">*</span> <span class="n">BookmarkManager</span><span class="o">::</span><span class="n">getAt</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 逻辑块1：类型定义
</span>    <span class="n">BookMarkURLElement</span> <span class="n">bookMarkElement</span><span class="p">(</span><span class="s">L""</span><span class="p">,</span> <span class="s">L""</span><span class="p">);</span>

    <span class="c1">// 逻辑块2：判断index是否在范围内
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">eResult_ok</span> <span class="o">!=</span> <span class="n">getURLItemAt</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">bookMarkElement</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 逻辑块3：创建对性并赋值
</span>    <span class="n">BookmarkInfo</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BookmarkInfo</span><span class="p">;</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">url</span> <span class="o">=</span> <span class="n">bookMarkElement</span><span class="p">.</span><span class="n">getUrl</span><span class="p">();</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">title</span> <span class="o">=</span> <span class="n">bookMarkElement</span><span class="p">.</span><span class="n">getTitle</span><span class="p">();</span>

    <span class="c1">// 逻辑块4：返回
</span>    <span class="k">return</span> <span class="n">info</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<h3><a class="anchor" id="5.4-类定义内部的空行" href="http://review.iauto.net/developrule/CodingRule#5.4-%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%86%85%E9%83%A8%E7%9A%84%E7%A9%BA%E8%A1%8C"><i class="fa fa-link"></i></a>5.4 类定义内部的空行</h3>

<h4><a class="anchor" id="5.4.1-不同区域间的空行" href="http://review.iauto.net/developrule/CodingRule#5.4.1-%E4%B8%8D%E5%90%8C%E5%8C%BA%E5%9F%9F%E9%97%B4%E7%9A%84%E7%A9%BA%E8%A1%8C"><i class="fa fa-link"></i></a>5.4.1 不同区域间的空行</h4>

<p>public/protected/private区域间要有空行。（参考<a href="http://review.iauto.net/developrule/CodingRule#5.4.5-%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84%E7%9A%84%E4%BE%8B%E5%AD%90">5.4.5</a>）<code>[必须]</code></p>

<h4><a class="anchor" id="5.4.2-功能分组" href="http://review.iauto.net/developrule/CodingRule#5.4.2-%E5%8A%9F%E8%83%BD%E5%88%86%E7%BB%84"><i class="fa fa-link"></i></a>5.4.2 功能分组</h4>

<ul>
<li>函数声明区域内，要根据功能的不同进行分组。（参考<a href="http://review.iauto.net/developrule/CodingRule#5.4.5-%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84%E7%9A%84%E4%BE%8B%E5%AD%90">5.4.5</a>）<code>[推荐]</code>

<ul>
<li>可以所有的构造/析构函数写在一起，后面用空行分隔。</li>
<li>可以按功能把函数分组，前后用空行隔开。</li>
</ul></li>
<li>变量定义区域内，要根据功能的不同进行分组。（参考<a href="http://review.iauto.net/developrule/CodingRule#5.4.5-%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84%E7%9A%84%E4%BE%8B%E5%AD%90">5.4.5</a>）<code>[推荐]</code>

<ul>
<li>如果类成员变量数量很多的时候，使用空行分组能显著提高代码可读性。</li>
<li>分组的原则与函数类似，按照功能进行分组。</li>
</ul></li>
</ul>

<h4><a class="anchor" id="5.4.3-不同类别成员" href="http://review.iauto.net/developrule/CodingRule#5.4.3-%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%88%AB%E6%88%90%E5%91%98"><i class="fa fa-link"></i></a>5.4.3 不同类别成员</h4>

<p>在相同的public/protected/private区域内，不同类别成员之间需要有空行分隔。（参考<a href="http://review.iauto.net/developrule/CodingRule#5.4.5-%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84%E7%9A%84%E4%BE%8B%E5%AD%90">5.4.5</a>）<code>[必须]</code></p>

<p>类成员分为以下类别：</p>

<ul>
<li>常量定义</li>
<li>自定义类型（<code>enum/union/struct/class</code>等）</li>
<li>静态成员变量</li>
<li>成员变量</li>
<li>构造函数/析构函数</li>
<li>操作符重载函数</li>
<li>多态函数</li>
<li>专有函数</li>
</ul>

<h4><a class="anchor" id="5.4.4-函数之间空行" href="http://review.iauto.net/developrule/CodingRule#5.4.4-%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%A9%BA%E8%A1%8C"><i class="fa fa-link"></i></a>5.4.4 函数之间空行</h4>

<p>函数的注释说明前，必需和前面的内容用空行分隔。（参考<a href="http://review.iauto.net/developrule/CodingRule#5.4.5-%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84%E7%9A%84%E4%BE%8B%E5%AD%90">5.4.5</a>）<code>[必须]</code></p>

<p><code>[例外]</code>如果是区域内第一个函数，则不需留空行。<code>[推荐]</code></p>

<h4><a class="anchor" id="5.4.5-类定义分组的例子" href="http://review.iauto.net/developrule/CodingRule#5.4.5-%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%88%86%E7%BB%84%E7%9A%84%E4%BE%8B%E5%AD%90"><i class="fa fa-link"></i></a>5.4.5 类定义分组的例子</h4>

<pre class="highlight"><span class="cm">/**
 * SampleClass概要说明
 *
 * SampleClass详细说明
 * ... ...
 */</span>
<span class="k">class</span> <span class="nc">SampleClass</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">/// constructor
</span>    <span class="n">SampleClass</span><span class="p">();</span>
    <span class="n">SampleClass</span><span class="p">(</span><span class="k">const</span> <span class="n">SampleClass</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>

    <span class="c1">/// destructor
</span>    <span class="o">~</span><span class="n">SampleClass</span><span class="p">();</span>

    <span class="c1">/// get the width.
</span>    <span class="kt">int</span> <span class="n">width</span><span class="p">();</span>

    <span class="cm">/**
     * set the width.
     *
     * Set the width of SampleClass.
     *
     * @param [IN] value: the height value
     *
     * @return void
     */</span>
    <span class="kt">void</span> <span class="n">setWidth</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>

    <span class="c1">/// get the height.
</span>    <span class="kt">int</span> <span class="n">height</span><span class="p">();</span>

    <span class="cm">/**
     * set the height.
     *
     * Set the height of SampleClass.
     *
     * @param [IN] value: the height value
     *
     * @return void
     */</span>
    <span class="kt">void</span> <span class="n">setHeight</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span> <span class="c1">// ↑ private之前为了和public区域区分，保留一个空行
</span>    <span class="k">static</span> <span class="kt">int</span> <span class="n">totalCount</span><span class="p">;</span>    <span class="c1">///&lt; total count
</span>
    <span class="kt">int</span> <span class="n">m_width</span><span class="p">;</span>              <span class="c1">///&lt; the width of SmapleCalss
</span>    <span class="kt">int</span> <span class="n">m_height</span><span class="p">;</span>             <span class="c1">///&lt; the height of SmapleCalss
</span><span class="p">};</span>
</pre>


<h3><a class="anchor" id="5.5-空格的使用" href="http://review.iauto.net/developrule/CodingRule#5.5-%E7%A9%BA%E6%A0%BC%E7%9A%84%E4%BD%BF%E7%94%A8"><i class="fa fa-link"></i></a>5.5 空格的使用</h3>

<h4><a class="anchor" id="5.5.1-用空格突出关键字" href="http://review.iauto.net/developrule/CodingRule#5.5.1-%E7%94%A8%E7%A9%BA%E6%A0%BC%E7%AA%81%E5%87%BA%E5%85%B3%E9%94%AE%E5%AD%97"><i class="fa fa-link"></i></a>5.5.1 用空格突出关键字</h4>

<ul>
<li><code>const</code>、<code>virtual</code>、<code>inline</code>、<code>case</code>等关键字之后要留一个空格。<code>[必须]</code></li>
<li><code>if</code>、<code>for</code>、<code>while</code>等关键字之后留一个空格再跟左括号<code>（</code>。<code>[必须]</code></li>
<li><code>do...while</code>语句中，<code>do</code>关键字之后留一个空格再跟大括号<code>{</code>。<code>[必须]</code></li>
<li>与关键字不同，函数名之后不要留空格，紧跟左括号<code>(</code>。<code>[必须]</code></li>
</ul>

<h4><a class="anchor" id="5.5.2-括号" href="http://review.iauto.net/developrule/CodingRule#5.5.2-%E6%8B%AC%E5%8F%B7"><i class="fa fa-link"></i></a>5.5.2 括号</h4>

<ul>
<li>左括号<code>(</code>之后不要留空格。<code>[必须]</code></li>
<li>右括号<code>)</code>之前不要留空格。<code>[必须]</code></li>
<li>右括号<code>)</code>和左大括号<code>{</code>之间留一个空格。<code>[必须]</code></li>
<li>左大括号<code>{</code>之后如果有内容，请保留一个空格。<code>[必须]</code></li>
<li>右大括号<code>}</code>之前如果有内容，请保留一个空格。<code>[必须]</code></li>
<li>如果左大括号<code>{</code>和右大括号<code>}</code>出现在一行，并且之间没有内容，请写在一起，不要留空格。<code>[必须]</code></li>
</ul>

<h4><a class="anchor" id="5.5.3-逗号和分号" href="http://review.iauto.net/developrule/CodingRule#5.5.3-%E9%80%97%E5%8F%B7%E5%92%8C%E5%88%86%E5%8F%B7"><i class="fa fa-link"></i></a>5.5.3 逗号和分号</h4>

<ul>
<li><code>,</code>之前不要留空格（除非出现在代码行开始），如<code>Function(x, y, z)</code>。<code>[必须]</code></li>
<li><code>,</code>之后要留空格（除非出现在代码行结尾），如<code>Function(x, y, z)</code>。<code>[必须]</code></li>
<li>可执行语句之后紧跟<code>;</code>，之间不要留空格或其他符号。<code>[必须]</code></li>
<li><code>;</code>之后有可执行的内容时，其后要留空格。<code>[必须]</code></li>
</ul>

<p><code>,</code>出现在行首参考<a href="http://review.iauto.net/developrule/CodingRule#4.6-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C">4.6</a>中的例子。</p>

<p><code>;</code>的例子：
</p><pre class="highlight">  <span class="k">for</span> <span class="p">(</span><span class="n">initialization</span><span class="p">;</span> <span class="n">condition</span><span class="p">;</span> <span class="n">update</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
</pre>

<pre class="highlight">  <span class="c1">// 没内容时写成
</span>  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
</pre>

<pre class="highlight">  <span class="c1">// 其他情形
</span>  <span class="k">for</span> <span class="p">(</span><span class="n">initialization</span><span class="p">;;)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(;</span> <span class="n">condition</span><span class="p">;)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(;;</span> <span class="n">update</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">initialization</span><span class="p">;</span> <span class="n">condition</span><span class="p">;)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">initialization</span><span class="p">;;</span> <span class="n">update</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(;</span> <span class="n">condition</span><span class="p">;</span> <span class="n">update</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
</pre>


<h4><a class="anchor" id="5.5.4-二元操作符" href="http://review.iauto.net/developrule/CodingRule#5.5.4-%E4%BA%8C%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><i class="fa fa-link"></i></a>5.5.4 二元操作符</h4>

<p>二元操作符前后要留空格，如<code>=</code> <code>+=</code> <code>&gt;=</code> <code>&lt;=</code> <code>+</code> <code>*</code> <code>%</code> <code>&amp;&amp;</code> <code>||</code> <code>&lt;&lt;</code> <code>^</code>等二元操作符的前后应当加空格。<code>[必须]</code></p>

<p>主要的二元操作符有：赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符。</p>

<h4><a class="anchor" id="5.5.5-一元操作符" href="http://review.iauto.net/developrule/CodingRule#5.5.5-%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><i class="fa fa-link"></i></a>5.5.5 一元操作符</h4>

<ul>
<li>一元操作符如<code>!</code> <code>~</code> <code>++</code> <code>--</code> <code>&amp;</code>（地址运算符）等与操作数之间不加空格。<code>[必须]</code></li>
<li><code>[]</code>的<code>[</code>的前后，<code>]</code>的前面均不加空格。<code>[必须]</code></li>
<li><code>.</code> <code>-&gt;</code>这类操作符前后不加空格。<code>[必须]</code></li>
</ul>

<h4><a class="anchor" id="5.5.6-不要冗余的空格" href="http://review.iauto.net/developrule/CodingRule#5.5.6-%E4%B8%8D%E8%A6%81%E5%86%97%E4%BD%99%E7%9A%84%E7%A9%BA%E6%A0%BC"><i class="fa fa-link"></i></a>5.5.6 不要冗余的空格</h4>

<p>为了代码行紧凑起见，不要过多的使用空格。<code>[推荐]</code></p>

<h4><a class="anchor" id="5.5.7-例子" href="http://review.iauto.net/developrule/CodingRule#5.5.7-%E4%BE%8B%E5%AD%90"><i class="fa fa-link"></i></a>5.5.7 例子</h4>

<ul>
<li>函数</li>
</ul>

<pre class="highlight"><span class="kt">void</span> <span class="n">func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span><span class="p">);</span>    <span class="c1">// 良好的风格
</span><span class="kt">void</span> <span class="n">func1</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">,</span><span class="kt">int</span> <span class="n">z</span><span class="p">);</span>     <span class="c1">// 不良的风格
</span></pre>


<ul>
<li><code>if</code>语句</li>
</ul>

<pre class="highlight">  <span class="k">if</span> <span class="p">(</span><span class="n">year</span> <span class="o">&gt;=</span> <span class="mi">2000</span><span class="p">)</span> <span class="p">{</span>         <span class="c1">// 良好的风格 
</span>      <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">year</span><span class="o">&gt;=</span><span class="mi">2000</span><span class="p">)</span> <span class="p">{</span>            <span class="c1">// 不良的风格 
</span>      <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">&gt;=</span><span class="n">b</span><span class="o">&amp;&amp;</span><span class="n">c</span><span class="o">&lt;=</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>            <span class="c1">// 不良的风格 
</span>      <span class="p">...</span>
  <span class="p">}</span>
</pre>


<ul>
<li><code>for</code>语句</li>
</ul>

<pre class="highlight">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">// 良好的风格 
</span>      <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>           <span class="c1">// 不良的风格 
</span>      <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span> <span class="o">++</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// 过多的空格 
</span>      <span class="p">...</span>
  <span class="p">}</span>
</pre>


<ul>
<li><code>while</code>语句</li>
</ul>

<pre class="highlight">  <span class="c1">// 良好的风格 
</span>  <span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
</pre>


<ul>
<li><code>do...while</code>语句</li>
</ul>

<pre class="highlight">  <span class="c1">// 良好的风格 
</span>  <span class="k">do</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">);</span>
</pre>


<ul>
<li>其他</li>
</ul>

<pre class="highlight">  <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="p">;</span>        <span class="c1">// 良好的风格
</span>  <span class="n">x</span><span class="o">=</span><span class="n">a</span><span class="o">&lt;</span><span class="n">b</span><span class="o">?</span><span class="n">a</span><span class="o">:</span><span class="n">b</span><span class="p">;</span>                  <span class="c1">// 不好的风格
</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>                <span class="c1">// 良好的风格
</span>  <span class="kt">int</span> <span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">;</span>              <span class="c1">// 不良的风格
</span>
  <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>               <span class="c1">// 不要写成 array [ 5 ] = 0;
</span>  <span class="n">a</span><span class="p">.</span><span class="n">Function</span><span class="p">();</span>               <span class="c1">// 不要写成 a . Function();
</span>  <span class="n">b</span><span class="o">-&gt;</span><span class="n">Function</span><span class="p">();</span>              <span class="c1">// 不要写成 b -&gt; Function();
</span></pre>


<h4><a class="anchor" id="5.5.8-注释中的空格" href="http://review.iauto.net/developrule/CodingRule#5.5.8-%E6%B3%A8%E9%87%8A%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC"><i class="fa fa-link"></i></a>5.5.8 注释中的空格</h4>

<p>为了注释能够明晰，便于阅读，注释中空格的使用有以下要求：</p>

<ul>
<li>注释标示符与注释内容之间，至少保留一个空格。<code>[必须]</code></li>
<li>语句行末的注释之前，至少保留一个空格。<code>[必须]</code></li>
<li>行末注释不允许有换行。<code>[必须]</code></li>
<li>代码行中除了行末注释之外不允许有其他任何注释。<code>[必须]</code></li>
</ul>

<p>注释中空格使用的例子。
</p><pre class="highlight">  <span class="c1">// this is a comment.
</span>  <span class="cm">/* this is a comment. */</span>

  <span class="n">statement</span><span class="p">;</span> <span class="c1">// This is a comment.
</span>  <span class="n">statement</span><span class="p">;</span> <span class="cm">/* This is a comment. */</span>       <span class="err">←</span> <span class="err">行末注释不允许有换行</span>
</pre>


<p>在代码行中错误使用注释的例子。
</p><pre class="highlight">  <span class="cm">/* xxx */</span> <span class="n">statement</span><span class="p">;</span>                      <span class="err">←</span> <span class="err">不允许！！！请使用行末注释</span>
  <span class="n">getStrLen</span><span class="p">(</span><span class="n">name</span><span class="cm">/* student name */</span><span class="p">);</span>        <span class="err">←</span> <span class="err">不允许！！！请使用行末注释</span>
</pre>


<h4><a class="anchor" id="5.5.9-其他" href="http://review.iauto.net/developrule/CodingRule#5.5.9-%E5%85%B6%E4%BB%96"><i class="fa fa-link"></i></a>5.5.9 其他</h4>

<h5><a class="anchor" id="5.5.9.1-三元操作中的空格" href="http://review.iauto.net/developrule/CodingRule#5.5.9.1-%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC"><i class="fa fa-link"></i></a>5.5.9.1 三元操作中的空格</h5>

<p>三元操作符<code>?:</code>和操作数之间必须留空格。<code>[必须]</code></p>

<pre class="highlight">  <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">?</span> <span class="n">c</span> <span class="o">:</span> <span class="n">d</span><span class="p">;</span>
</pre>


<h5><a class="anchor" id="5.5.9.2-构造函数的初始化列表中的空格" href="http://review.iauto.net/developrule/CodingRule#5.5.9.2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC"><i class="fa fa-link"></i></a>5.5.9.2 构造函数的初始化列表中的空格</h5>

<p>类的构造函数的初始化列表中的空格遵循下面的规范。<code>[必须]</code></p>

<ul>
<li><code>:</code>和表达式之间必须有空格</li>
<li><code>,</code>的规则参考<a href="http://review.iauto.net/developrule/CodingRule#5.5.3-%E9%80%97%E5%8F%B7%E5%92%8C%E5%88%86%E5%8F%B7">5.5.3</a></li>
</ul>

<p>参考<a href="http://review.iauto.net/developrule/CodingRule#4.6-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%8D%A2%E8%A1%8C">4.6</a>中的例子。</p>

<h5><a class="anchor" id="5.5.9.3-位域中的空格" href="http://review.iauto.net/developrule/CodingRule#5.5.9.3-%E4%BD%8D%E5%9F%9F%E4%B8%AD%E7%9A%84%E7%A9%BA%E6%A0%BC"><i class="fa fa-link"></i></a>5.5.9.3 位域中的空格</h5>

<p>位域操作符<code>:</code>和操作数之间留空格。<code>[必须]</code></p>

<pre class="highlight"><span class="k">struct</span> <span class="n">MyStruct</span>
<span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">bitValue1</span> <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">bitValue2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int32_t</span>           <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 不使用，会自动置0
</span>    <span class="kt">int32_t</span> <span class="n">bitValue3</span> <span class="o">:</span> <span class="mi">6</span><span class="p">;</span>  <span class="c1">// 从下一个int32_t开始
</span>    <span class="kt">int32_t</span>           <span class="o">:</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 空2bits不使用
</span>    <span class="kt">int32_t</span> <span class="n">bitValue4</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre>


<h2><a class="anchor" id="6.-代码" href="http://review.iauto.net/developrule/CodingRule#6.-%E4%BB%A3%E7%A0%81"><i class="fa fa-link"></i></a>6. 代码</h2>

<h3><a class="anchor" id="6.1-每条语句一个逻辑" href="http://review.iauto.net/developrule/CodingRule#6.1-%E6%AF%8F%E6%9D%A1%E8%AF%AD%E5%8F%A5%E4%B8%80%E4%B8%AA%E9%80%BB%E8%BE%91"><i class="fa fa-link"></i></a>6.1 每条语句一个逻辑</h3>

<p>代码行的逻辑要尽可能的简单，不要一条语句行多个逻辑。<code>[推荐]</code></p>

<h4><a class="anchor" id="6.1.1-条件表达时中的逻辑判断" href="http://review.iauto.net/developrule/CodingRule#6.1.1-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E6%97%B6%E4%B8%AD%E7%9A%84%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD"><i class="fa fa-link"></i></a>6.1.1 条件表达时中的逻辑判断</h4>

<h5><a class="anchor" id="6.1.1.1-条件表达式中的赋值操作" href="http://review.iauto.net/developrule/CodingRule#6.1.1.1-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><i class="fa fa-link"></i></a>6.1.1.1 条件表达式中的赋值操作</h5>

<p>禁止在条件表达式中使用赋值语句：<code>[必须]</code></p>

<pre class="highlight">  <span class="k">if</span> <span class="p">(</span><span class="n">isConnected</span> <span class="o">=</span> <span class="n">network</span><span class="o">-&gt;</span><span class="n">isConnected</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// 不可以！禁止在条件表达式中使用赋值语句
</span>      <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// 正确的写法：
</span>  <span class="n">bool</span> <span class="n">isConnected</span> <span class="o">=</span> <span class="n">network</span><span class="o">-&gt;</span><span class="n">isConnected</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isConnected</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
</pre>


<h5><a class="anchor" id="6.1.1.2-条件表达式中的函数调用" href="http://review.iauto.net/developrule/CodingRule#6.1.1.2-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><i class="fa fa-link"></i></a>6.1.1.2 条件表达式中的函数调用</h5>

<p>建议不要条件表达式中进行函数调用。<code>[推荐]</code></p>

<p><code>例外</code>除非这个函数比较简单，例如检查状态等。</p>

<pre class="highlight">  <span class="c1">// 不好的例子：
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">VOLUME1</span> <span class="o">==</span> <span class="n">GetVolume</span><span class="p">(</span><span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">,</span> <span class="n">param3</span><span class="p">))</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// 好的例子：
</span>  <span class="kt">int</span> <span class="n">vol</span> <span class="o">=</span> <span class="n">GetVolume</span><span class="p">(</span><span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">,</span> <span class="n">param3</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">VOLUME1</span> <span class="o">==</span> <span class="n">vol</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// 简单函数调用的例子：
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">network</span><span class="o">-&gt;</span><span class="n">isConnected</span><span class="p">())</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
</pre>


<h5><a class="anchor" id="6.1.1.3-条件表达式中的算数运算" href="http://review.iauto.net/developrule/CodingRule#6.1.1.3-%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97"><i class="fa fa-link"></i></a>6.1.1.3 条件表达式中的算数运算</h5>

<p>不要条件表达式中进行算数运算。<code>[推荐]</code></p>

<pre class="highlight">  <span class="c1">// 不好的例子：
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">MAX_LEN</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">length1</span> <span class="o">+</span> <span class="n">length2</span><span class="p">))</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// 好的例子：
</span>  <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">length1</span> <span class="o">+</span> <span class="n">length2</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MAX_LEN</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
</pre>


<h4><a class="anchor" id="6.1.2-函数调用" href="http://review.iauto.net/developrule/CodingRule#6.1.2-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><i class="fa fa-link"></i></a>6.1.2 函数调用</h4>

<p>不要在函数调用中使用函数调用来替换实参。<code>[推荐]</code></p>

<pre class="highlight">  <span class="c1">// 不好的例子：
</span>  <span class="n">SetSystemVolume</span><span class="p">(</span><span class="n">GetVolume</span><span class="p">(</span><span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">,</span> <span class="n">param3</span><span class="p">));</span>

  <span class="c1">// 好的例子：
</span>  <span class="kt">int</span> <span class="n">vol</span> <span class="o">=</span> <span class="n">GetVolume</span><span class="p">(</span><span class="n">param1</span><span class="p">,</span> <span class="n">param2</span><span class="p">,</span> <span class="n">param3</span><span class="p">);</span>
  <span class="n">SetSystemVolume</span><span class="p">(</span><span class="n">vol</span><span class="p">);</span>
</pre>


<h3><a class="anchor" id="6.2-括号" href="http://review.iauto.net/developrule/CodingRule#6.2-%E6%8B%AC%E5%8F%B7"><i class="fa fa-link"></i></a>6.2 括号</h3>

<h4><a class="anchor" id="6.2.1-用括号避免操作符优先级问题" href="http://review.iauto.net/developrule/CodingRule#6.2.1-%E7%94%A8%E6%8B%AC%E5%8F%B7%E9%81%BF%E5%85%8D%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98"><i class="fa fa-link"></i></a>6.2.1 用括号避免操作符优先级问题</h4>

<p>为了避免逻辑操作符优先级问题，在每个逻辑操作（包含操作符及其操作数）的两端加上<code>()</code>。<code>[必须]</code></p>

<p>很多Bug的产生是由于逻辑操作符优先级导致的，比如判断整数<code>a</code>的<code>bit0</code>是否为<code>1</code>的表达式：
</p><pre class="highlight">  <span class="c1">// 错误！"=="优先级大于"&amp;"
</span>  <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">a</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// 加括号以后
</span>  <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
</pre>


<p>在类似的情况下，使用括号来规避错误。</p>

<h4><a class="anchor" id="6.2.2-在宏中使用括号" href="http://review.iauto.net/developrule/CodingRule#6.2.2-%E5%9C%A8%E5%AE%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%8B%AC%E5%8F%B7"><i class="fa fa-link"></i></a>6.2.2 在宏中使用括号</h4>

<p>宏函数展开的时候，只是简单的按照宏函数定义的规则，用宏函数中的参数进行展开。如果请在宏函数中，每个参数的前后都加上括号。<code>[必须]</code></p>

<p>看下面的例子：
</p><pre class="highlight"><span class="cp">#define mul(x, y)    x * y
</span>
<span class="kt">void</span> <span class="nf">SomeMethod</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 这里展开以后，其实是a*b+1
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>        <span class="c1">// 期待12，实际输出10
</span><span class="p">}</span>
</pre>


<p>正确的例子：
</p><pre class="highlight"><span class="cp">#define mul(x, y)    ((x) * (y))
</span></pre>


<h3><a class="anchor" id="6.3-比较" href="http://review.iauto.net/developrule/CodingRule#6.3-%E6%AF%94%E8%BE%83"><i class="fa fa-link"></i></a>6.3 比较</h3>

<h4><a class="anchor" id="6.3.1-整数类型与常量比较" href="http://review.iauto.net/developrule/CodingRule#6.3.1-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%AF%94%E8%BE%83"><i class="fa fa-link"></i></a>6.3.1 整数类型与常量比较</h4>

<p>整形与常量比较时，把常量放在前面。<code>[推荐]</code></p>

<p>这样做的主要目的是避免把<code>==</code>错误的写成<code>=</code>（实际上，这是经常会发生的事情）。
</p><pre class="highlight">  <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 本意是if(b == 0)
</span>      <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// 如果常量放在前面：
</span>  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">=</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 本意是if(0 == b)
</span>      <span class="p">...</span>
  <span class="p">}</span>
  <span class="c1">// 以上写法会报一个编译错误。
</span></pre>


<h4><a class="anchor" id="6.3.2-指针类型与常量比较" href="http://review.iauto.net/developrule/CodingRule#6.3.2-%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%AF%94%E8%BE%83"><i class="fa fa-link"></i></a>6.3.2 指针类型与常量比较</h4>

<p>这个与整形类似，需要把常量指针放在前面。<code>[推荐]</code></p>

<p>这里的常量指针最常用的是NULL，但是还有一些其他的常量指针，比如this，常量字符串等。</p>

<pre class="highlight">  <span class="c1">// 和NULL比较
</span>  <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// 和this字符串比较
</span>  <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span></pre>


<h4><a class="anchor" id="6.3.3-避免常量字符串的直接比较" href="http://review.iauto.net/developrule/CodingRule#6.3.3-%E9%81%BF%E5%85%8D%E5%B8%B8%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B4%E6%8E%A5%E6%AF%94%E8%BE%83"><i class="fa fa-link"></i></a>6.3.3 避免常量字符串的直接比较</h4>

<p>不要直接用<code>==</code>判断字符串是否相等。<code>[必须]</code></p>

<p>通常情况下，完全相同的常量字符串会被统一化，比如：
</p><pre class="highlight">  <span class="kt">char</span> <span class="o">*</span><span class="n">str1</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">str2</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="n">str1</span> <span class="o">==</span> <span class="n">str2</span><span class="p">));</span> <span class="c1">// 错误！返回1
</span></pre>


<p>但是这样做是不可靠的，比如如果两个字符串来自不同的动态库，那个字符串的地址就会不一样。</p>

<h4><a class="anchor" id="6.3.4-布尔类型的比较" href="http://review.iauto.net/developrule/CodingRule#6.3.4-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83"><i class="fa fa-link"></i></a>6.3.4 布尔类型的比较</h4>

<p>布尔类型的比较，不要使用<code>==</code>或者<code>!=</code>，直接使用或者<code>!</code>即可。<code>[必须]</code>
</p><pre class="highlight">  <span class="k">if</span> <span class="p">(</span><span class="nb">false</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 不要这么用
</span>      <span class="p">...</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 正确的做法
</span>      <span class="p">...</span>
  <span class="p">}</span>
</pre>


<h4><a class="anchor" id="6.3.5-浮点数的比较" href="http://review.iauto.net/developrule/CodingRule#6.3.5-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83"><i class="fa fa-link"></i></a>6.3.5 浮点数的比较</h4>

<p>无论是<code>float</code>还是<code>double</code>类型的变量，都有精度限制。所以一定要避免将浮点变量<code>==</code>或<code>！=</code>与数字进行比较。<code>[必须]</code></p>

<p>一般的项目中可能会提供一个浮点数与0比较的宏，比如：
</p><pre class="highlight"><span class="cp">#define EPSILON 0.00001
#define IsFloatZero(x) (((x) &gt;= -EPSILON) &amp;&amp; ((x) &lt;= EPSILON))
</span>
<span class="kt">void</span> <span class="nf">SomeMethod</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IsFloatZero</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre>


<h2><a class="anchor" id="6.4-常量" href="http://review.iauto.net/developrule/CodingRule#6.4-%E5%B8%B8%E9%87%8F"><i class="fa fa-link"></i></a>6.4 常量</h2>

<h3><a class="anchor" id="6.4.1-避免常数" href="http://review.iauto.net/developrule/CodingRule#6.4.1-%E9%81%BF%E5%85%8D%E5%B8%B8%E6%95%B0"><i class="fa fa-link"></i></a>6.4.1 避免常数</h3>

<p>在代码中，不要直接使用常数（0除外），应该把常数定义成常量，在代码中直接用常量来表示。<code>[必须]</code></p>

<ul>
<li>没有注释的常量出现在代码中，很难让人理解。</li>
</ul>

<pre class="highlight">  <span class="n">err</span> <span class="o">=</span> <span class="n">SomeFunc</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// -1代表什么意义？
</span>      <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">==</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// -2代表什么意义？
</span>      <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
</pre>


<ul>
<li>方便在需求变更时对代码做修改。下面的这个例子里出现了三处常量：</li>
</ul>

<pre class="highlight"><span class="k">static</span> <span class="kt">char</span> <span class="n">array</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="kt">void</span> <span class="nf">initArry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">99</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">checkCharCount</span><span class="p">(</span><span class="kt">char</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="o">++</span><span class="n">count</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>这个时候，如果需求有改变，要求数组的大小为200，那么就至少有三处要修改。</p>

<h4><a class="anchor" id="6.4.2-使用正确的常数" href="http://review.iauto.net/developrule/CodingRule#6.4.2-%E4%BD%BF%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%B8%B8%E6%95%B0"><i class="fa fa-link"></i></a>6.4.2 使用正确的常数</h4>

<p>C语言中有一些常用的常数，比如指针的<code>NULL</code>，字符结尾的<code>'\0'</code>等，请在合适的时候使用这些常数，不要偷梁换柱。<code>[必须]</code>
</p><pre class="highlight">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptr</span><span class="p">)</span>               <span class="c1">// 不好的做法
</span>  <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>        <span class="c1">// 不好的做法
</span>  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ptr</span><span class="p">)</span>           <span class="c1">// 不好的做法
</span>  <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">ptr</span><span class="p">)</span>        <span class="c1">// 正确的做法
</span>
  <span class="k">const</span> <span class="kt">int32_t</span> <span class="n">MAX_STR_LEN</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">MAX_STR_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

  <span class="n">strncpy</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">someone</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">MAX_STR_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="c1">// 下面的语句确保name有一个字符串结尾字符
</span>  <span class="n">name</span><span class="p">[</span><span class="n">MAX_STR_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">// 不好的做法
</span>  <span class="n">name</span><span class="p">[</span><span class="n">MAX_STR_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span> <span class="c1">// 正确的做法
</span></pre>


<h3><a class="anchor" id="6.5-变量" href="http://review.iauto.net/developrule/CodingRule#6.5-%E5%8F%98%E9%87%8F"><i class="fa fa-link"></i></a>6.5 变量</h3>

<h4><a class="anchor" id="6.5.1-每行只声明/定义一个变量" href="http://review.iauto.net/developrule/CodingRule#6.5.1-%E6%AF%8F%E8%A1%8C%E5%8F%AA%E5%A3%B0%E6%98%8E/%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F"><i class="fa fa-link"></i></a>6.5.1 每行只声明/定义一个变量</h4>

<p>每个变量的声明/定义占用一行，否则会降低代码的可读性。<code>[必须]</code>
</p><pre class="highlight">  <span class="c1">// 不好的例子
</span>  <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="o">*</span><span class="n">top</span><span class="p">;</span>
</pre>

<pre class="highlight">  <span class="c1">// 改进后的例子：
</span>  <span class="kt">int</span>  <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span>  <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre>


<h4><a class="anchor" id="6.5.2-变量在定义时初始化" href="http://review.iauto.net/developrule/CodingRule#6.5.2-%E5%8F%98%E9%87%8F%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E5%88%9D%E5%A7%8B%E5%8C%96"><i class="fa fa-link"></i></a>6.5.2 变量在定义时初始化</h4>

<p>很多Bug的产生都与变量未初始化有很大的关系，所以在定义变量时对变量初始化。<code>[必须]</code></p>

<p>以下几种类型的初始化需要特别注意一下：</p>

<ul>
<li>指针类型：如果没有特定的值用于初始化，请务必初始化为NULL</li>
<li>枚举类型：一般枚举类型在声明时，会在末尾增加一个无效的枚举项，这个枚举项可以用来初始化</li>
<li>数组类型，可以在定义时直接赋值为0，比如：</li>
</ul>

<pre class="highlight">  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
</pre>


<ul>
<li>引用类型必须在定义时初始化（引用类型的类成员变量在初始化列表进行初始化），但是切忌初始化为空引用：</li>
</ul>

<pre class="highlight">  <span class="c1">// 切忌空引用！！！
</span>  <span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="mi">0</span><span class="p">);</span>
</pre>


<h4><a class="anchor" id="6.5.3-C类型结构体初始化" href="http://review.iauto.net/developrule/CodingRule#6.5.3-C%E7%B1%BB%E5%9E%8B%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E5%8C%96"><i class="fa fa-link"></i></a>6.5.3 C类型结构体初始化</h4>

<p>C类型的结构体类型：C类型的结构体类型无法在定义时加入构造函数，一般可以在定义变量的时候直接赋值，或者在定义以后用<code>memset</code>初始化。<code>[推荐]</code>
</p><pre class="highlight"><span class="k">struct</span> <span class="n">tagSize</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="n">tagSize</span> <span class="n">Size</span><span class="p">;</span>
</pre>

<pre class="highlight">  <span class="c1">// 初始化方式1：定义时赋值
</span>  <span class="n">Size</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">};</span>

  <span class="c1">// 初始化方式2：memset
</span>  <span class="n">Size</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>

  <span class="c1">// 初始化方式3：直接赋值
</span>  <span class="n">Size</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>

  <span class="c1">// 初始化方式4：memcpy，不推荐
</span>  <span class="n">Size</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Size</span><span class="p">));</span>
</pre>


<h4><a class="anchor" id="6.5.4-C++类型的结构体与类的初始化" href="http://review.iauto.net/developrule/CodingRule#6.5.4-C++%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><i class="fa fa-link"></i></a>6.5.4 C++类型的结构体与类的初始化</h4>

<p>在C++中，类与结构体除了默认的访问权限外，没有区别。对待C++中的结构体，应该像对待类一样进行处理。</p>

<ul>
<li>初始化C++的类和结构体，最好办法是定义构造函数。<code>[推荐]</code></li>
<li>如果结构体中有类成员时

<ul>
<li>必须使用<code>class</code>来定义。<code>[必须]</code></li>
<li>除构造函数外，不能定义任何成员函数。<code>[必须]</code></li>
</ul></li>
<li>禁止使用<code>memset/memcpy</code>对类进行初始化。<code>[必须]</code></li>
<li>类中有非静态成员变量时，必须定义构造函数。<code>[必须]</code></li>
<li>在类构造函数中，必须初始化所有的非静态成员变量。<code>[必须]</code></li>
<li>类构造函数中的初始化列表中，成员变量出现的顺序必需和定义的顺序一致。<code>[必须]</code></li>
</ul>

<p>例子：
</p><pre class="highlight"><span class="c1">// 错误！因为有std::string类型成员，不能定义成struct。
</span><span class="k">struct</span> <span class="n">Student</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

    <span class="n">Student</span><span class="p">();</span>
<span class="p">};</span>
</pre>

<pre class="highlight"><span class="c1">// 正确的方法：
</span><span class="k">class</span> <span class="nc">Student</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>

    <span class="n">Student</span><span class="p">();</span>
<span class="p">};</span>
</pre>

<pre class="highlight"><span class="c1">// 构造函数的实现
</span><span class="n">Student</span><span class="o">::</span><span class="n">Student</span><span class="p">()</span>
    <span class="o">:</span> <span class="n">name</span><span class="p">()</span>
    <span class="p">,</span> <span class="n">id</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</pre>

<pre class="highlight">  <span class="c1">// 使用构造，运行
</span>  <span class="n">Student</span> <span class="n">a</span><span class="p">();</span>

  <span class="c1">// 错误！通过memset初始化，会破坏std::string类内部的结构
</span>  <span class="n">Student</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>

  <span class="c1">// 直接赋值，允许
</span>  <span class="n">Student</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

  <span class="c1">// 错误！通过memcpy初始化，会破坏std::string类内部的结构
</span>  <span class="n">Student</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Size</span><span class="p">));</span>
</pre>


<h3><a class="anchor" id="6.5.5-避免变量名覆盖" href="http://review.iauto.net/developrule/CodingRule#6.5.5-%E9%81%BF%E5%85%8D%E5%8F%98%E9%87%8F%E5%90%8D%E8%A6%86%E7%9B%96"><i class="fa fa-link"></i></a>6.5.5 避免变量名覆盖</h3>

<p>变量名覆盖是一定要在代码中避免的！因为覆盖很容易引起混淆。<code>[必须]</code></p>

<p>以下是几个典型的覆盖的例子：</p>

<ul>
<li>作用域覆盖：</li>
</ul>

<pre class="highlight"><span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">MyMethod</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>     <span class="c1">// 错误！count变量名覆盖
</span>        <span class="p">...</span>
    <span class="p">}</span>
   <span class="p">...</span>
<span class="p">}</span>
</pre>


<ul>
<li>子类成员变量覆盖父类成员变量：</li>
</ul>

<pre class="highlight"><span class="k">class</span> <span class="nc">Base</span> 
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">m_value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> 
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">m_value</span><span class="p">;</span>    <span class="c1">// 错误！父类中的m_value被覆盖
</span><span class="p">};</span>
</pre>


<h3><a class="anchor" id="6.6-预处理指令" href="http://review.iauto.net/developrule/CodingRule#6.6-%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><i class="fa fa-link"></i></a>6.6 预处理指令</h3>

<p>预处理指令开始的#号必须始终处于一行的行首。<code>[必须]</code><br>
The hash mark that starts a preprocessor directive should always be at the beginning of the line.
</p><pre class="highlight"><span class="c1">// 好的例子：预处理指令从行首开始
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">lopsided_score</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if DISASTER_PENDING      // 正确！从行首开始
</span>        <span class="n">DropEverything</span><span class="p">();</span>
<span class="cp">#   if NOTIFY             // 也可以，#号后空格不是必需的
</span>        <span class="n">NotifyClient</span><span class="p">();</span>
<span class="cp">#   endif
#endif
</span>        <span class="n">BackToNormal</span><span class="p">();</span>
    <span class="p">}</span>
</pre>

<pre class="highlight"><span class="c1">// 不好的例子：有缩进的预处理指令
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">lopsided_score</span><span class="p">)</span> <span class="p">{</span>
        <span class="cp">#if DISASTER_PENDING  // 错误！"#if"必须位于行首
</span>        <span class="n">DropEverything</span><span class="p">();</span>
        <span class="cp">#endif                // 错误！不要缩进"#endif"
</span>        <span class="n">BackToNormal</span><span class="p">();</span>
    <span class="p">}</span>
</pre>


<h2><a class="anchor" id="7.-控制流" href="http://review.iauto.net/developrule/CodingRule#7.-%E6%8E%A7%E5%88%B6%E6%B5%81"><i class="fa fa-link"></i></a>7. 控制流</h2>

<h3><a class="anchor" id="7.1-if的写法" href="http://review.iauto.net/developrule/CodingRule#7.1-if%E7%9A%84%E5%86%99%E6%B3%95"><i class="fa fa-link"></i></a>7.1 <code>if</code>的写法</h3>

<p><code>if/else</code>写法的基本规则：<code>[必须]</code></p>

<ul>
<li><code>if/else if/else</code>分别独占一行</li>
<li><code>if/else if/else</code>必须有{}</li>
<li><code>{</code>和<code>if/else if/else</code>语句写在同一行</li>
<li><code>{</code>前留一个空格</li>
<li><code>}</code>独占一行</li>
<li>有<code>else if</code>的时候，最后的<code>else</code>不可省略</li>
</ul>

<p>以下是一个不加<code>{}</code>导致错误的例子：
</p><pre class="highlight">  <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span>  <span class="c1">// 这个else if与谁匹配？！
</span>      <span class="p">...</span>
</pre>


<p>以下是正确的写法：
</p><pre class="highlight">  <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
  <span class="p">}</span>
</pre>


<h3><a class="anchor" id="7.2-while的写法" href="http://review.iauto.net/developrule/CodingRule#7.2-while%E7%9A%84%E5%86%99%E6%B3%95"><i class="fa fa-link"></i></a>7.2 <code>while</code>的写法</h3>

<p><code>while</code>写法的基本规则与<code>if/else</code>基本相同。<code>[必须]</code></p>

<ul>
<li><code>while</code>必须有<code>{}</code></li>
<li><code>{</code>和<code>while</code>语句写在同一行</li>
<li><code>{</code>前留一个空格</li>
<li><code>}</code>独占一行</li>
</ul>

<p><code>while</code>的例子：
</p><pre class="highlight">  <span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
</pre>


<h3><a class="anchor" id="7.3-do...while的写法" href="http://review.iauto.net/developrule/CodingRule#7.3-do...while%E7%9A%84%E5%86%99%E6%B3%95"><i class="fa fa-link"></i></a>7.3 <code>do...while</code>的写法</h3>

<p><code>do...while</code>写法的基本规则：<code>[必须]</code></p>

<ul>
<li><code>do/while</code>分别独占一行</li>
<li><code>do...while</code>必须有<code>{}</code></li>
<li><code>{</code>和<code>do</code>语句写在同一行</li>
<li><code>{</code>和<code>do</code>之间留一个空格</li>
<li><code>}</code>和<code>while</code>语句写在同一行</li>
<li><code>}</code>和<code>while</code>之间留一个空格</li>
</ul>

<p><code>do...while</code>的例子：
</p><pre class="highlight">  <span class="k">do</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">);</span>
</pre>


<h3><a class="anchor" id="7.4-switch/case的写法" href="http://review.iauto.net/developrule/CodingRule#7.4-switch/case%E7%9A%84%E5%86%99%E6%B3%95"><i class="fa fa-link"></i></a>7.4 <code>switch/case</code>的写法</h3>

<p><code>switch/case</code>写法的基本规则：<code>[必须]</code></p>

<ul>
<li><code>{</code>与<code>switch</code>语句写在同一行</li>
<li><code>{</code>前留一个空格</li>
<li><code>}</code>独占一行</li>
<li><code>case</code>不需要缩进（避免过多的缩进）</li>
<li>推荐在<code>case</code>中使用<code>{}</code></li>
<li>如果某个<code>case</code>没有<code>break</code>，要注释说明</li>
<li>必须有<code>default</code>分支</li>
<li><code>default</code>无论是否有内容，<code>break</code>不能省略</li>
</ul>

<p><code>switch/case</code>的例子：
</p><pre class="highlight">  <span class="k">switch</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">// case不需要缩进
</span>      <span class="p">{</span>
          <span class="n">statements</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// 有内容，又不需要break的地方，在这里要加入注释
</span>  <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
      <span class="p">{</span>
          <span class="n">statements</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="c1">// 无内容，又不需要break的地方，在这里加入注释
</span>  <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
      <span class="p">{</span>
          <span class="n">statements</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="k">default</span><span class="o">:</span> <span class="c1">// default分支不能省略
</span>      <span class="p">{</span>
          <span class="n">statements</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span> <span class="c1">// default的break语句不能省略
</span>  <span class="p">}</span>
</pre>


<h3><a class="anchor" id="7.5-for的写法" href="http://review.iauto.net/developrule/CodingRule#7.5-for%E7%9A%84%E5%86%99%E6%B3%95"><i class="fa fa-link"></i></a>7.5 <code>for</code>的写法</h3>

<p><code>for</code>写法的基本规则：<code>[必须]</code></p>

<ul>
<li><code>for</code>必须有<code>{}</code></li>
<li><code>{</code>和<code>for</code>语句写在同一行</li>
<li><code>{</code>前留一个空格</li>
<li><code>}</code>独占一行</li>
</ul>

<p><code>for</code>的例子：
</p><pre class="highlight">  <span class="k">for</span> <span class="p">(</span><span class="n">initialization</span><span class="p">;</span> <span class="n">condition</span><span class="p">;</span> <span class="n">update</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
  <span class="p">}</span>
</pre>


<h2><a class="anchor" id="8.-命名规范" href="http://review.iauto.net/developrule/CodingRule#8.-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><i class="fa fa-link"></i></a>8. 命名规范</h2>

<h3><a class="anchor" id="8.1-命名规则" href="http://review.iauto.net/developrule/CodingRule#8.1-%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><i class="fa fa-link"></i></a>8.1 命名规则</h3>

<p>代码中遵循下面的命名规则，在同一个类，或者同一文件中，相同类别的命名必须保持一致的命名规则。<code>[必须]</code></p>

<p>相同的机能模块建议采用相同的命名规则。<code>[推荐]</code></p>

<h4><a class="anchor" id="8.1.1-骆驼命名法" href="http://review.iauto.net/developrule/CodingRule#8.1.1-%E9%AA%86%E9%A9%BC%E5%91%BD%E5%90%8D%E6%B3%95"><i class="fa fa-link"></i></a>8.1.1 骆驼命名法</h4>

<p>骆驼式命令法，正如它的名称所表示的那样，是指混合使用大小写字母来构成变量和函数的名字。骆驼命名法的几个特点：</p>

<ul>
<li>名字中不同的单词之间不需要任何分隔</li>
<li>从第二个单词开始，每个单词的首字母大写，其余字母小写</li>
</ul>

<p>※注1：部分情形下，第一个单词首字母也大写。（参考<a href="http://review.iauto.net/developrule/CodingRule#8.2-%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99">8.2</a>）<br>
※注2：骆驼命名法一般不要求变量根据类型增加前缀。<br>
※注3：加数据类型前缀的变量命名法，要求变量类型前缀字母全小写。（也满足骆驼命名法）<br></p>

<h4><a class="anchor" id="8.1.2-变量命名规则" href="http://review.iauto.net/developrule/CodingRule#8.1.2-%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><i class="fa fa-link"></i></a>8.1.2 变量命名规则</h4>

<p>变量命名遵循下面的命名规则。</p>

<table><thead>
<tr>
<th>类别</th>
<th>命名规则</th>
</tr>
</thead><tbody>
<tr>
<td>临时变量</td>
<td><code>fileName</code>：骆驼命名法<code>[推荐]</code><br><code>strFileName</code>：加变量类型前缀的骆驼命名法<br><code>file_name</code>：所有字母小写，单词之间用<code>_</code>分隔</td>
</tr>
<tr>
<td>结构体/联合体成员变量</td>
<td><code>fileName</code>：骆驼命名法<code>[推荐]</code><br><code>strFileName</code>：加变量类型前缀的骆驼命名法<br><code>file_name</code>：所有字母小写，单词之间用<code>_</code>分隔<br>　　※仅限于C库中的函数：扩展名为<code>.c</code>源文件及其对应的<code>.h</code>文件</td>
</tr>
<tr>
<td>类成员变量</td>
<td><code>m_fileName</code>：<code>m_</code>+骆驼命名法<code>[推荐]</code><br><code>m_strFileName</code>：<code>m_</code>+加变量类型前缀的骆驼命名法</td>
</tr>
<tr>
<td>类静态成员变量</td>
<td><code>m_FileName</code>：<code>m_</code>+首字母大写的骆驼命名法<code>[推荐]</code><br><code>m_sFileName</code>：<code>m_s</code>+首字母大写的骆驼命名法<br><code>s_strFileName</code>：<code>s_</code>+加变量类型前缀的骆驼命名法</td>
</tr>
<tr>
<td>静态变量</td>
<td><code>FileName</code>：首字母大写的骆驼命名法<code>[推荐]</code><br><code>s_strFileName</code>：<code>s_</code>+加变量类型前缀的骆驼命名法<br><code>s_file_name</code>：<code>s_</code>+所有字母小写，单词之间用<code>_</code>分隔<br>　　※仅限于C库中的函数：扩展名为<code>.c</code>源文件及其对应的<code>.h</code>文件</td>
</tr>
<tr>
<td>全局变量（不推荐使用）</td>
<td><code>FileName</code>：首字母大写的骆驼命名法<code>[推荐]</code><br><code>g_strFileName</code>：<code>g_</code>+加变量类型前缀的骆驼命名法<br><code>g_file_name</code>：<code>g_</code>+所有字母小写，单词之间用<code>_</code>分隔<br>　　※仅限于C库中的函数：扩展名为<code>.c</code>源文件及其对应的<code>.h</code>文件</td>
</tr>
</tbody></table>

<h4><a class="anchor" id="8.1.3-函数命名规则" href="http://review.iauto.net/developrule/CodingRule#8.1.3-%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><i class="fa fa-link"></i></a>8.1.3 函数命名规则</h4>

<p>函数命名遵循下面的命名规则。</p>

<table><thead>
<tr>
<th>类别</th>
<th>命名规则</th>
</tr>
</thead><tbody>
<tr>
<td>类成员函数</td>
<td><code>setFileName</code>：骆驼命名法<code>[推荐]</code><br><code>SetFileName</code>：首字母大写的骆驼命名法</td>
</tr>
<tr>
<td>非类成员函数</td>
<td><code>SetFileName</code>：首字母大写的骆驼命名法<br><code>set_file_name</code>：所有字母小写，单词之间用<code>_</code>分隔<br>　　※仅限于C库中的函数：扩展名为<code>.c</code>源文件及其对应的<code>.h</code>文件</td>
</tr>
</tbody></table>

<h4><a class="anchor" id="8.1.4-其他命名规则" href="http://review.iauto.net/developrule/CodingRule#8.1.4-%E5%85%B6%E4%BB%96%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><i class="fa fa-link"></i></a>8.1.4 其他命名规则</h4>

<p>其他的一些命名遵循下面的命名规则。</p>

<table><thead>
<tr>
<th>类别</th>
<th>命名规则</th>
</tr>
</thead><tbody>
<tr>
<td>类/结构体/联合体</td>
<td><code>DefinedType</code>：首字母大写的骆驼命名法<code>[推荐]</code><br><code>defined_type</code>：所有字母小写，单词之间用<code>_</code>分隔<br>　　※仅限于C库中的函数：扩展名为<code>.c</code>源文件及其对应的<code>.h</code>文件</td>
</tr>
<tr>
<td>枚举</td>
<td><code>DeviceType</code>：首字母大写的骆驼命名法<code>[推荐]</code><br><code>DEVICE_TYPE</code>：所有字母全大写，单词之间用下划线<code>_</code>分隔<br><code>device_type</code>：所有字母小写，单词之间用<code>_</code>分隔<br>　　※仅限于C库中的函数：扩展名为<code>.c</code>源文件及其对应的<code>.h</code>文件</td>
</tr>
<tr>
<td>枚举值</td>
<td>对应上面的两种定义方式：<br><code>DeviceType_SdCard</code>：枚举类型名+首字母大写的骆驼命名法，两者之间用下划线<code>_</code>分隔<br><code>DEVICE_TYPE_SD_CARD</code>：枚举类型名+<code>_</code>+所有字母全大写，单词之间用下划线<code>_</code>分隔<br><code>device_type_sd_card</code>：所有字母小写，单词之间用<code>_</code>分隔<br>　　※仅限于C库中的函数：扩展名为<code>.c</code>源文件及其对应的<code>.h</code>文件</td>
</tr>
<tr>
<td>常量</td>
<td>每个单词所有字母都大写，单词之间用下划线<code>_</code>分隔</td>
</tr>
</tbody></table>

<p>※注：有的项目或者模块会要求在类型定义之前追加前缀，例如，<code>NI</code>，<code>SRCH_</code>等。这些前缀不受本规范限制，但是除去前缀部分后必须满足上述命名规则。</p>

<h3><a class="anchor" id="8.2-名副其实" href="http://review.iauto.net/developrule/CodingRule#8.2-%E5%90%8D%E5%89%AF%E5%85%B6%E5%AE%9E"><i class="fa fa-link"></i></a>8.2 名副其实</h3>

<h4><a class="anchor" id="8.2.1-使用有意义的单词命名" href="http://review.iauto.net/developrule/CodingRule#8.2.1-%E4%BD%BF%E7%94%A8%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%8D%95%E8%AF%8D%E5%91%BD%E5%90%8D"><i class="fa fa-link"></i></a>8.2.1 使用有意义的单词命名</h4>

<p>变量的命名应该能够忠实的表达他的意思。
</p><pre class="highlight"><span class="kt">void</span> <span class="n">MyCopy</span><span class="p">(</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">type</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>          <span class="c1">// 不好的命名
</span><span class="kt">void</span> <span class="n">MyCopy</span><span class="p">(</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="n">type</span><span class="o">&amp;</span> <span class="n">src</span><span class="p">);</span>      <span class="c1">// 更有意义的命名
</span></pre>


<h4><a class="anchor" id="8.2.2-不要任意对单词缩写" href="http://review.iauto.net/developrule/CodingRule#8.2.2-%E4%B8%8D%E8%A6%81%E4%BB%BB%E6%84%8F%E5%AF%B9%E5%8D%95%E8%AF%8D%E7%BC%A9%E5%86%99"><i class="fa fa-link"></i></a>8.2.2 不要任意对单词缩写</h4>

<p>单词过长的时候，一般会对单词进行缩写。以下是几个缩写的例子：</p>

<p><code>error</code>-&gt;<code>err</code>, <code>message</code>-&gt;<code>msg</code>。</p>

<p>但是随意的缩写会影响到代码的可读性。以下是几个很恶劣的缩写：</p>

<p><code>timeout</code>-&gt;<code>to</code>, <code>implementation</code>-&gt;<code>imp</code></p>

<p>这样的缩写太容易引起歧义，如果不能让人从缩写中迅速还原原始的单词意义，那么这个缩写就是失败的。</p>

<h3><a class="anchor" id="8.3-函数命名" href="http://review.iauto.net/developrule/CodingRule#8.3-%E5%87%BD%E6%95%B0%E5%91%BD%E5%90%8D"><i class="fa fa-link"></i></a>8.3 函数命名</h3>

<h4><a class="anchor" id="8.3.1-自然语言原则（动词+名词）" href="http://review.iauto.net/developrule/CodingRule#8.3.1-%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%8E%9F%E5%88%99%EF%BC%88%E5%8A%A8%E8%AF%8D+%E5%90%8D%E8%AF%8D%EF%BC%89"><i class="fa fa-link"></i></a>8.3.1 自然语言原则（动词+名词）</h4>

<p>函数的命名，采用动词+名词的形式更能符合自然语言的语法，也更容易理解。比如，某个函数实现了把某块内存清0的功能，那个这个函数应该叫做<code>ZeroMemory</code>，而不是<code>MemoryZero</code>。</p>

<p>但是也有一些场合，采用名词+动词的方式可能会更加合适。比如，要用C语言实现一组内存操作的接口：
</p><pre class="highlight"><span class="c1">// 接近自然语言的命名方式
</span><span class="kt">void</span> <span class="n">SetMem</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">mem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">CopyMem</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="c1">// 名词+动词的方式：
</span><span class="kt">void</span> <span class="n">MemSet</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">mem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">MemCopy</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
</pre>


<p>显然，在这种场合下，使用名词+动词的方式显然更合适。</p>

<p>一个比较折中的原则是：用C语言实现一组功能相似的函数时，采用名词+动词的命名方式，其他情况下，请采用自然语言的方式。</p>

<h4><a class="anchor" id="8.3.2-配对命名" href="http://review.iauto.net/developrule/CodingRule#8.3.2-%E9%85%8D%E5%AF%B9%E5%91%BD%E5%90%8D"><i class="fa fa-link"></i></a>8.3.2 配对命名</h4>

<p>如果两个函数具有相关性，那么命名最好能够互相匹配。常用的配对命名：</p>

<ul>
<li>Add/Remove</li>
<li>Insert/Delete</li>
<li>Start/Stop</li>
<li>Begin/End</li>
<li>Send/Receive</li>
<li>First/Last</li>
<li>Get/Release</li>
<li>Put/Get</li>
<li>Up/Down</li>
<li>Show/Hide</li>
<li>Source/Target</li>
<li>Open/Close</li>
<li>Source/Destination</li>
<li>Increment/Decrement</li>
<li>Lock/Unlock</li>
<li>Old/New</li>
<li>Next/Previous</li>
</ul>

<h4><a class="anchor" id="8.3.3-特殊的配对：get/set" href="http://review.iauto.net/developrule/CodingRule#8.3.3-%E7%89%B9%E6%AE%8A%E7%9A%84%E9%85%8D%E5%AF%B9%EF%BC%9Aget/set"><i class="fa fa-link"></i></a>8.3.3 特殊的配对：get/set</h4>

<p>get/set配对时，一般可以把get省略掉。比如说：
</p><pre class="highlight"><span class="k">class</span> <span class="nc">Sample</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">width</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">setWidth</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">m_width</span><span class="p">;</span>
<span class="p">};</span>
</pre>


<h4><a class="anchor" id="8.3.4-特殊的配对：bool类型" href="http://review.iauto.net/developrule/CodingRule#8.3.4-%E7%89%B9%E6%AE%8A%E7%9A%84%E9%85%8D%E5%AF%B9%EF%BC%9Abool%E7%B1%BB%E5%9E%8B"><i class="fa fa-link"></i></a>8.3.4 特殊的配对：bool类型</h4>

<p>bool类型一般使用is/set配对。
</p><pre class="highlight"><span class="k">class</span> <span class="nc">Sample</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">bool</span> <span class="n">isEnabled</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">setEnabled</span><span class="p">(</span><span class="n">bool</span> <span class="n">value</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">bool</span> <span class="n">m_enabled</span><span class="p">;</span>
<span class="p">};</span>
</pre>


<h4><a class="anchor" id="8.3.5-避免与系统函数重名" href="http://review.iauto.net/developrule/CodingRule#8.3.5-%E9%81%BF%E5%85%8D%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E9%87%8D%E5%90%8D"><i class="fa fa-link"></i></a>8.3.5 避免与系统函数重名</h4>

<p>与系统函数重名导致的Bug隐蔽性很强，在编码阶段就要极力避免这种情况的发生，这就要求程序员要尽可能多的了解系统函数。</p>

<ul>
<li>C库函数<br>C库函数虽多，但是由于很常用，记住并不是很困难。</li>
<li>Linux系统函数<br>Linux API的命名法很特殊，一般采用小写单词+下划线分隔的方式，与骆驼命名法差异很大，一般不容易重名。</li>
<li>Windows系统函数<br>Windows系统函数大都使用C类型函数，命名方法与骆驼命名法是一样的，而且数量极多，特别是短函数，很容易重名。比如SetRectEmpty等。避免与Windows系统函数重名，尽量少用C类型的函数是最有效的办法；如果一定要，而且拿不准的，不妨查一下MSDN。</li>
</ul>

<h4><a class="anchor" id="8.3.6-避免太简单的函数名和类名" href="http://review.iauto.net/developrule/CodingRule#8.3.6-%E9%81%BF%E5%85%8D%E5%A4%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E7%B1%BB%E5%90%8D"><i class="fa fa-link"></i></a>8.3.6 避免太简单的函数名和类名</h4>

<p>如果没有namespace限制的话，全局函数名和类名是直接暴露在全局命名空间中的。如果使用一些非常通用的名词或者动词来命名的话，很容易造成冲突。</p>

<p>比如说，有一个模块用来实现字幕的显示，定义个一个类<code>Rect</code>来表示每条字幕在屏幕上的位置。在把字幕模块和视频播放模块进行集成的时候，很不幸，视频播放模块也定义一个类<code>Rect</code>来表示视频在屏幕上的位置，那么这两个同名的Rect就会引起混淆。</p>

<p>避免这类冲突的最好办法，就是避免使用这些简单词汇来命名。如果的确是需要用，那么请加上namespace。</p>

<h2><a class="anchor" id="9.-类的规范" href="http://review.iauto.net/developrule/CodingRule#9.-%E7%B1%BB%E7%9A%84%E8%A7%84%E8%8C%83"><i class="fa fa-link"></i></a>9. 类的规范</h2>

<h3><a class="anchor" id="9.1-类成员变量/函数定义规范" href="http://review.iauto.net/developrule/CodingRule#9.1-%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E8%A7%84%E8%8C%83"><i class="fa fa-link"></i></a>9.1 类成员变量/函数定义规范</h3>

<h4><a class="anchor" id="9.1.1-不要依赖于默认的访问权限" href="http://review.iauto.net/developrule/CodingRule#9.1.1-%E4%B8%8D%E8%A6%81%E4%BE%9D%E8%B5%96%E4%BA%8E%E9%BB%98%E8%AE%A4%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><i class="fa fa-link"></i></a>9.1.1 不要依赖于默认的访问权限</h4>

<p>请把所有的成员变量/函数都显示的放到合适的<code>public</code>/<code>protected</code>/<code>private</code>区块内，不能依赖默认的访问权限。<code>[必须]</code>
</p><pre class="highlight"><span class="k">class</span> <span class="nc">SampleClass</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">someMethod</span><span class="p">();</span>    <span class="c1">// 错误！需要加上合适的修饰符（public/protected/private）
</span>    <span class="p">...</span>
<span class="p">};</span>
</pre>


<p>下面的写法是正确的：
</p><pre class="highlight"><span class="k">class</span> <span class="nc">SampleClass</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">someMethod</span><span class="p">();</span>    <span class="c1">// 正确，说明someMethod是一个private方法
</span>    <span class="p">...</span>
<span class="p">};</span>
</pre>


<h4><a class="anchor" id="9.1.2-不要定义public类型的成员变量" href="http://review.iauto.net/developrule/CodingRule#9.1.2-%E4%B8%8D%E8%A6%81%E5%AE%9A%E4%B9%89public%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><i class="fa fa-link"></i></a>9.1.2 不要定义public类型的成员变量</h4>

<p>在<code>class</code>中不要定义public类型的成员变量。<code>[必须]</code></p>

<p><code>[例外]</code>如果某些类的重要功能是数据容器，可以定义<code>public</code>类型的成员变量，不过这样的类里除构造函数外，不能定义任何成员函数。（参考<a href="http://review.iauto.net/developrule/CodingRule#6.5.4-C++%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">6.5.4</a>）</p>

<p>定义<code>public</code>类型的成员变量会破坏类的封装性。一般来说，可以定义一组<code>public</code>的<code>get/set</code>方法来访问私有的成员变量。</p>

<h4><a class="anchor" id="9.1.3-和类关系密切的类型，请定义在类的内部" href="http://review.iauto.net/developrule/CodingRule#9.1.3-%E5%92%8C%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%AF%86%E5%88%87%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E8%AF%B7%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8"><i class="fa fa-link"></i></a>9.1.3 和类关系密切的类型，请定义在类的内部</h4>

<p>定义在类内部的主要目的是避免命名空间被污染。<code>[推荐]</code>
</p><pre class="highlight"><span class="k">class</span> <span class="nc">SampleStyle</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">enum</span> <span class="n">Style</span>
    <span class="p">{</span>
        <span class="n">Style_Sunken</span><span class="p">,</span>
        <span class="n">Style_Thick</span><span class="p">,</span>
        <span class="n">Style_Plain</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="n">setStyle</span><span class="p">(</span><span class="n">Style</span> <span class="n">style</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">Style</span> <span class="n">style</span><span class="p">();</span>
<span class="p">};</span>
</pre>


<h4><a class="anchor" id="9.1.4-class内的排列顺序" href="http://review.iauto.net/developrule/CodingRule#9.1.4-class%E5%86%85%E7%9A%84%E6%8E%92%E5%88%97%E9%A1%BA%E5%BA%8F"><i class="fa fa-link"></i></a>9.1.4 <code>class</code>内的排列顺序</h4>

<p>类定义中，请遵循以下排列顺序：</p>

<ul>
<li>public区域在前，protected区域其次，private区域最后。<code>[必须]</code></li>
<li>每个区域内同类型成员需放在一起。<code>[必须]</code></li>
<li>每个区域内不同类型成员按照下面的顺序排列：<code>[推荐]</code>

<ul>
<li>常量定义</li>
<li>自定义类型（<code>enum/union/struct/class</code>等）</li>
<li>静态成员变量</li>
<li>成员变量</li>
<li>构造函数/析构函数</li>
<li>操作符重载函数</li>
<li>多态函数</li>
<li>专有函数</li>
</ul></li>
</ul>

<h3><a class="anchor" id="9.2-继承与多态" href="http://review.iauto.net/developrule/CodingRule#9.2-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81"><i class="fa fa-link"></i></a>9.2 继承与多态</h3>

<h4><a class="anchor" id="9.2.1-避免多继承" href="http://review.iauto.net/developrule/CodingRule#9.2.1-%E9%81%BF%E5%85%8D%E5%A4%9A%E7%BB%A7%E6%89%BF"><i class="fa fa-link"></i></a>9.2.1 避免多继承</h4>

<ul>
<li>多继承很容易带来混淆，而且会降低执行效率，因此要尽可能的避免使用。<code>[推荐]</code></li>
<li>如果实在需要使用多继承，可以通过使用接口继承来代替。<code>[推荐]</code><br></li>
</ul>

<h4><a class="anchor" id="9.2.2-不要把不必要的方法放到抽象层次很高的基类中" href="http://review.iauto.net/developrule/CodingRule#9.2.2-%E4%B8%8D%E8%A6%81%E6%8A%8A%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95%E6%94%BE%E5%88%B0%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1%E5%BE%88%E9%AB%98%E7%9A%84%E5%9F%BA%E7%B1%BB%E4%B8%AD"><i class="fa fa-link"></i></a>9.2.2 不要把不必要的方法放到抽象层次很高的基类中</h4>

<p>要保证每个虚函数都是有意义的，不要把不必要的方法放到抽象层次很高的基类中，这会带来以下几方面的问题：<code>[推荐]</code></p>

<ul>
<li>会增加基类虚表的大小，造成空间浪费</li>
<li>影响代码的可读性</li>
</ul>

<h3><a class="anchor" id="9.3-构造函数" href="http://review.iauto.net/developrule/CodingRule#9.3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><i class="fa fa-link"></i></a>9.3 构造函数</h3>

<h4><a class="anchor" id="9.3.1-避免默认复制构造函数和=操作符" href="http://review.iauto.net/developrule/CodingRule#9.3.1-%E9%81%BF%E5%85%8D%E9%BB%98%E8%AE%A4%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C=%E6%93%8D%E4%BD%9C%E7%AC%A6"><i class="fa fa-link"></i></a>9.3.1 避免默认复制构造函数和<code>=</code>操作符</h4>

<p>在定义<code>class</code>时避免默认复制构造函数和<code>=</code>操作符。<code>[必须]</code></p>

<p>允许默认复制构造函数是一种很危险的行为。看下面的例子，程序会崩溃！
</p><pre class="highlight"><span class="k">class</span> <span class="nc">SampleA</span>
<span class="p">{</span>
<span class="k">public</span><span class="p">;</span>
    <span class="n">SampleA</span><span class="p">()</span> <span class="p">{</span> <span class="n">m_ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span> <span class="p">}</span>

    <span class="o">~</span><span class="n">SampleA</span><span class="p">()</span> 
    <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">m_ptr</span><span class="p">);</span>
        <span class="n">m_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">m_ptr</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">SampleA</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">SampleA</span> <span class="n">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// 会导致m_ptr二次释放，程序崩溃！
</span></pre>


<p>另外，复制构造函数可能还会导致Slicing的问题。
※细节请参考其他资料，如侯俊杰的《深入浅出MFC 2》。</p>

<p>避免默认复制构造函数的原则：</p>

<ul>
<li>如果类在设计的时候就是禁止拷贝的，声明复制构造函数和重载<code>=</code>操作符，但是别写实现</li>
<li>如果类在设计的时候是允许拷贝的，而且类中会动态的分配资源，实现复制构造函数并重载<code>=</code>操作符</li>
</ul>

<h4><a class="anchor" id="9.3.2-单个参数的类构造函数使用explicit关键字" href="http://review.iauto.net/developrule/CodingRule#9.3.2-%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8explicit%E5%85%B3%E9%94%AE%E5%AD%97"><i class="fa fa-link"></i></a>9.3.2 单个参数的类构造函数使用explicit关键字</h4>

<p>对单个参数的类构造函数使用explicit关键字。<code>[推荐]</code><br>
Use the C++ keyword explicit for constructors with one argument.</p>

<p>由于单参数的类构造会带有隐式转换的功能，经常导致一些意料外的处理。所以对于单参数的类构造函数必须加上explicit，如果需要某些类型转换的场合，显式定义转换时的行为。<br>
Normally, if a constructor takes one argument, it can be used as a conversion. For instance, if you define Foo::Foo(string name) and then pass a string to a function that expects a Foo, the constructor will be called to convert the string into a Foo and will pass the Foo to your function for you. This can be convenient but is also a source of trouble when things get converted and new objects created without you meaning them to. Declaring a constructor explicit prevents it from being invoked implicitly as a conversion.</p>

<pre class="highlight"><span class="k">class</span> <span class="nc">MyClass</span> 
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">MyClass</span><span class="p">();</span>
    <span class="k">explicit</span> <span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">);</span>   <span class="c1">// 使用explicit
</span>    <span class="o">~</span><span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
</pre>


<h2><a class="anchor" id="10.-函数" href="http://review.iauto.net/developrule/CodingRule#10.-%E5%87%BD%E6%95%B0"><i class="fa fa-link"></i></a>10. 函数</h2>

<h3><a class="anchor" id="10.1-函数参数" href="http://review.iauto.net/developrule/CodingRule#10.1-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><i class="fa fa-link"></i></a>10.1 函数参数</h3>

<h4><a class="anchor" id="10.1.1-避免过多的参数" href="http://review.iauto.net/developrule/CodingRule#10.1.1-%E9%81%BF%E5%85%8D%E8%BF%87%E5%A4%9A%E7%9A%84%E5%8F%82%E6%95%B0"><i class="fa fa-link"></i></a>10.1.1 避免过多的参数</h4>

<p>在代码中，要避免定义带有过多参数的函数。<code>[推荐]</code></p>

<ul>
<li>影响代码可读性和编码效率<br>参数过多过长，会造成函数定义很长，甚至需要换行，看起来很不方便。</li>
<li>降低编码效率<br>如果参数过多，则很难被记忆。在写函数调用的时候，要经常在函数定义和代码间切换，一不小心就容易把参数写错。</li>
<li>造成性能损失<br>在函数调用时，参数会压栈；函数调用结束以后，参数还会出栈。如果参数过多，在压栈和出栈的时候就会浪费大量的时间。</li>
<li>增大栈内存的使用量<br>在函数调用时，参数会压栈。如果参数过多，会造成栈内存使用过大。在很多系统中，都会对线程的栈大小做限制，这有可能会导致栈溢出。</li>
</ul>

<p>对于参数过多的函数，可以通过以下方式进行优化：<code>[推荐]</code></p>

<ul>
<li>看哪些参数其实是可以避免的。比如有的参数可以通过另外一个参数或者通过其他的方式取得，那么这个参数就是可以避免的。</li>
<li>把联系比较紧密的参数打包成结构体，然后通过引用或者指针作为参数传递。</li>
<li>如果有些参数在很多函数中都要用，而且使用频率很高，那么不妨把他放到类定义中，作为类成员函数。</li>
</ul>

<h4><a class="anchor" id="10.1.2-避免值传递" href="http://review.iauto.net/developrule/CodingRule#10.1.2-%E9%81%BF%E5%85%8D%E5%80%BC%E4%BC%A0%E9%80%92"><i class="fa fa-link"></i></a>10.1.2 避免值传递</h4>

<p>函数调用中的值传递很容易带来运行速度问题，特别是对于结构比较复杂的类。值传递的参数，在函数调用过程中会被复制构造，因此造成性能损失。<code>[推荐]</code></p>

<p>避免值传递的最佳方案是使用引用。<code>[推荐]</code></p>

<h4><a class="anchor" id="10.1.3-注意参数顺序" href="http://review.iauto.net/developrule/CodingRule#10.1.3-%E6%B3%A8%E6%84%8F%E5%8F%82%E6%95%B0%E9%A1%BA%E5%BA%8F"><i class="fa fa-link"></i></a>10.1.3 注意参数顺序</h4>

<p>不合理的参数顺序，容易造成代码中的书写错误，同时也会造成代码阅读困难。</p>

<p>用来共同表示一个内容的参数，请放在一起。<code>[推荐]</code></p>

<p>比如说，要定义一个Blit函数，需要传入源设备和目标设备的信息。其中表示设备信息的有设备Handle和几何信息。应该这样写：
</p><pre class="highlight"><span class="c1">// 清晰的写法
</span><span class="kt">void</span> <span class="n">Blit</span><span class="p">(</span><span class="n">Painter</span> <span class="n">src</span><span class="p">,</span> <span class="n">Rect</span> <span class="n">srcRect</span><span class="p">,</span> <span class="n">Painter</span> <span class="n">dst</span><span class="p">,</span> <span class="n">Rect</span> <span class="n">dstRect</span><span class="p">);</span>

<span class="c1">// 混乱的写法：
</span><span class="kt">void</span> <span class="n">Blit</span><span class="p">(</span><span class="n">Painter</span> <span class="n">src</span><span class="p">,</span> <span class="n">Painter</span> <span class="n">dst</span><span class="p">,</span> <span class="n">Rect</span> <span class="n">srcRect</span><span class="p">,</span> <span class="n">Rect</span> <span class="n">dstRect</span><span class="p">);</span>
</pre>


<p>按照重要性排列参数。<code>[推荐]</code></p>

<p>比如说，如果函数参数里要传递一个Buffer信息，这信息包括Buffer的地址和长度。那么应该把地址放在前面，长度放在后面。
</p><pre class="highlight"><span class="c1">// 清晰的写法
</span><span class="kt">void</span> <span class="n">InitBuffer</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="c1">// 混乱的写法：
</span><span class="kt">void</span> <span class="n">InitBuffer</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buffer</span><span class="p">);</span>
</pre>


<p>参数的顺序要符合自然的思考和语言习惯。<code>[推荐]</code></p>

<p>比如说，描述一个物体的尺寸，都是先说宽度，后说高度，那么当宽度和高度同时出现在参数中的时候，就应该把宽度放在前面；描述一个人的时候，总是先说身高，后说体重，那么当身高和体重同时出现在参数中时，身高应该放在前面。</p>

<h4><a class="anchor" id="10.1.4-形参名不能省略" href="http://review.iauto.net/developrule/CodingRule#10.1.4-%E5%BD%A2%E5%8F%82%E5%90%8D%E4%B8%8D%E8%83%BD%E7%9C%81%E7%95%A5"><i class="fa fa-link"></i></a>10.1.4 形参名不能省略</h4>

<p>函数的形参名必须要写，不能省略。<code>[必须]</code>
</p><pre class="highlight"><span class="kt">int</span> <span class="n">method</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>          <span class="c1">// 不可以！不能省略形参名
</span></pre>

<pre class="highlight"><span class="kt">int</span> <span class="n">method</span><span class="p">(</span><span class="kt">int</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// OK
</span></pre>


<h3><a class="anchor" id="10.2-使用内联函数" href="http://review.iauto.net/developrule/CodingRule#10.2-%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><i class="fa fa-link"></i></a>10.2 使用内联函数</h3>

<p>积极使用内联函数。<code>[推荐]</code></p>

<ul>
<li>内联函数能够显著的提高程序运行效率，特别是对于体积短小，调用频繁的函数。</li>
<li>在C++中，最常见的办法就是把函数实现直接写在头文件中。</li>
<li>需要注意的是，虚函数是无法内联的，所以虚函数的实现最好还是放在cpp中。</li>
</ul>

<p>一个例子：
</p><pre class="highlight"><span class="k">class</span> <span class="nc">Smaple</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Sample</span><span class="p">();</span>

    <span class="kr">inline</span> <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">width</span><span class="p">()</span> <span class="c1">// 不好的做法！虚函数无法内联。
</span>    <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_width</span><span class="p">;</span>
    <span class="p">}</span>

<span class="n">privite</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">m_width</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<h3><a class="anchor" id="10.3-积极使用const" href="http://review.iauto.net/developrule/CodingRule#10.3-%E7%A7%AF%E6%9E%81%E4%BD%BF%E7%94%A8const"><i class="fa fa-link"></i></a>10.3 积极使用const</h3>

<p>在函数定义中使用const能够很大的提高程序的安全性，但是这是一个经常会被人忽视的领域。建议大家都养成良好的习惯，积极的使用const。<code>[推荐]</code></p>

<ul>
<li>如果参数是不需要修改的，请用const修饰参数</li>
<li>如果不希望在函数调用中修改类成员（比如一些get类的函数），请用const修饰函数</li>
</ul>

<p>一个例子：
</p><pre class="highlight"><span class="k">class</span> <span class="nc">Smaple</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Sample</span><span class="p">();</span>

    <span class="kt">int</span> <span class="n">width</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>                 <span class="c1">// 用const修饰函数
</span>    <span class="kt">void</span> <span class="n">setWidth</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">);</span>    <span class="c1">// 用const修饰参数
</span>
<span class="n">privite</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">m_width</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<h2><a class="anchor" id="11.-内存" href="http://review.iauto.net/developrule/CodingRule#11.-%E5%86%85%E5%AD%98"><i class="fa fa-link"></i></a>11. 内存</h2>

<h3><a class="anchor" id="11.1-内存分配" href="http://review.iauto.net/developrule/CodingRule#11.1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><i class="fa fa-link"></i></a>11.1 内存分配</h3>

<ul>
<li>内存分配以后，一定要判断是否成功。<code>[必须]</code>

<ul>
<li>在嵌入式环境下，一定不能假设内存分配都是成功的，必要的检查和错误处理是一定要有的。</li>
</ul></li>
<li>内存分配以后，要先初始化再使用。<code>[推荐]</code>

<ul>
<li>从堆中分配的内存是有记忆效果的，记忆上次被使用后的内容，内存分配函数是不会自动把新分配的内存清0的，这个初始化过程必须程序员自己来做。</li>
</ul></li>
</ul>

<p>一个例子：
</p><pre class="highlight"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 指针初始化为NULL;
</span>    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">MAX_NAME_LEN</span><span class="p">];</span>
    <span class="c1">// 使用NULL判断指针是否有效（内存是否分配成功）
</span>    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 初始化
</span>        <span class="n">memeset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MAX_NAME_LEN</span><span class="p">);</span>

        <span class="p">...</span>

        <span class="k">delete</span><span class="p">[]</span> <span class="n">name</span><span class="p">;</span>
        <span class="c1">// 内存被释放以后，把指针重新设置为NULL
</span>        <span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<h3><a class="anchor" id="11.2-始终用NULL表示无效内存" href="http://review.iauto.net/developrule/CodingRule#11.2-%E5%A7%8B%E7%BB%88%E7%94%A8NULL%E8%A1%A8%E7%A4%BA%E6%97%A0%E6%95%88%E5%86%85%E5%AD%98"><i class="fa fa-link"></i></a>11.2 始终用NULL表示无效内存</h3>

<p>在任何情况下，都应该用NULL表示空指针：<code>[必须]</code></p>

<ul>
<li>建立空的指针变量的时候，请初始化为NULL</li>
<li>请用NULL判断指针是否有效</li>
<li>指针指向的内存被释放以后，应该重新设置为NULL</li>
</ul>

<p>参考<a href="http://review.iauto.net/developrule/CodingRule#11.1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">11.1</a>中的例子。</p>

<p>虽然在大部分系统上，C库会把NULL定义为0，但理论上来说C库可以把NULL定义为任意值，所以始终使用NULL而不是0，才是避免这种情况的唯一方法。</p>

<h3><a class="anchor" id="11.3-慎重对待静态内存分配和栈内存分配" href="http://review.iauto.net/developrule/CodingRule#11.3-%E6%85%8E%E9%87%8D%E5%AF%B9%E5%BE%85%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E6%A0%88%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><i class="fa fa-link"></i></a>11.3 慎重对待静态内存分配和栈内存分配</h3>

<h4><a class="anchor" id="11.3.1-内存冗余" href="http://review.iauto.net/developrule/CodingRule#11.3.1-%E5%86%85%E5%AD%98%E5%86%97%E4%BD%99"><i class="fa fa-link"></i></a>11.3.1 内存冗余</h4>

<p>动态内存分配的优势之一就是按需分配，用多少分多少，不过静态分配和栈中分配做不到（C99可以，不过大部分编译器还不支持），这就会造成内容冗余，静态分配导致的内存冗余尤为严重。</p>

<h4><a class="anchor" id="11.3.2-静态分配" href="http://review.iauto.net/developrule/CodingRule#11.3.2-%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D"><i class="fa fa-link"></i></a>11.3.2 静态分配</h4>

<p>使用静态分配时，需要考虑到下面因素。<code>[推荐]</code></p>

<ul>
<li>生命周期无法管理

<ul>
<li>静态分配的内存，在程序加载的时候就会占用内存，直到程序退出才会被最终释放，这之间会常驻内存。而且由于静态分配内存的冗余性，这对系统资源造成很大的浪费。一般来说，内存一般都不是一直要被用到的，在不需要的时候，静态分配的内存是无法被主动释放的！</li>
</ul></li>
<li>会造成ROM过大

<ul>
<li>如果在分配静态内存的时候做了初始化，那么这块内存也会同时占用ROM空间。大量的静态内存分配很可能会导致ROM空间过大。</li>
</ul></li>
</ul>

<h4><a class="anchor" id="11.3.3-栈内分配" href="http://review.iauto.net/developrule/CodingRule#11.3.3-%E6%A0%88%E5%86%85%E5%88%86%E9%85%8D"><i class="fa fa-link"></i></a>11.3.3 栈内分配</h4>

<p>栈内分配容易导致栈溢出。嵌入式环境下栈一般都很小，在栈中分配内存，特别是有冗余的大内存，很容易导致栈溢出，这个Bug是很难被追踪的，所以不要使用。<code>[推荐]</code></p>

<h4><a class="anchor" id="11.3.4-禁止使用可变长的数组定义" href="http://review.iauto.net/developrule/CodingRule#11.3.4-%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8%E5%8F%AF%E5%8F%98%E9%95%BF%E7%9A%84%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89"><i class="fa fa-link"></i></a>11.3.4 禁止使用可变长的数组定义</h4>

<p>虽然C99中开始支持可变长的数组定义，即用变量来声明数组的长度。但是由于分配基本是在栈中，如果不对变量大小进行判断，很容易导致栈溢出的问题。所以</p>

<ul>
<li>开发中禁止使用可变长的数组定义。<code>[必须]</code></li>
</ul>

<p>遇到此类需求时，推荐改用new等堆分配方式。
</p><pre class="highlight">  <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">getLengthFromSomething</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="n">length</span><span class="p">];</span>    <span class="c1">// 错误！禁用可变长数组
</span></pre>


<h3><a class="anchor" id="11.4-慎用C类型的内存操作API" href="http://review.iauto.net/developrule/CodingRule#11.4-%E6%85%8E%E7%94%A8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9CAPI"><i class="fa fa-link"></i></a>11.4 慎用C类型的内存操作API</h3>

<h4><a class="anchor" id="11.4.1-不要对非原生类型的变量使用内存操作" href="http://review.iauto.net/developrule/CodingRule#11.4.1-%E4%B8%8D%E8%A6%81%E5%AF%B9%E9%9D%9E%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C"><i class="fa fa-link"></i></a>11.4.1 不要对非原生类型的变量使用内存操作</h4>

<p><code>memset</code>，<code>memcpy</code>对原生类型的变量操作很好，在C编程中，处处可见。但是如果用在C++中，经常会破坏掉虚指针，一定不能对类使用。<code>[必须]</code></p>

<p>以下是一个破坏虚指针的例子：
</p><pre class="highlight"><span class="k">class</span> <span class="nc">Sample</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fn</span><span class="p">()</span> <span class="p">{}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">m_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">MyMethod</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span> <span class="c1">// 错误！会破坏虚函数指针表
</span>
    <span class="n">a</span><span class="p">.</span><span class="n">fn</span><span class="p">();</span> <span class="c1">// 程序崩溃！因为虚函数指针表被破坏了
</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre>


<h4><a class="anchor" id="11.4.2-注意memcpy的overlap问题" href="http://review.iauto.net/developrule/CodingRule#11.4.2-%E6%B3%A8%E6%84%8Fmemcpy%E7%9A%84overlap%E9%97%AE%E9%A2%98"><i class="fa fa-link"></i></a>11.4.2 注意<code>memcpy</code>的overlap问题</h4>

<p><code>memcpy</code>不是一直都正确的，如果目标地址在源地址之后，且地址间有重叠，会出现错误结果：
</p><pre class="highlight">  <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>

  <span class="c1">// 期待变为{0, 0, 1, 2, 3, 4, 5, 6, 7, 8}
</span>  <span class="n">memcpy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">9</span><span class="p">);</span>
  <span class="c1">// 拷贝以后实际变为{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
</span></pre>


<p>C语言提供的<code>memmove</code>的函数可以解决此问题，不过带来了性能上的损失。最好的办法不是把所有的<code>memcpy</code>都改为<code>memmove</code>，而是尽量避免overlap的出现；在出现overlap的地方，再去使用<code>memmove</code>。<code>[推荐]</code></p>

<h4><a class="anchor" id="11.4.3-禁用strcpy,-strcat,-sprintf" href="http://review.iauto.net/developrule/CodingRule#11.4.3-%E7%A6%81%E7%94%A8strcpy,-strcat,-sprintf"><i class="fa fa-link"></i></a>11.4.3 禁用<code>strcpy</code>, <code>strcat</code>, <code>sprintf</code></h4>

<p>由于<code>strcpy</code>，<code>strcat</code>，<code>sprintf</code>等函数容易导致内存越界的问题，在开发中禁止使用。改用有越界保护的相应函数<code>strncpy</code>, <code>strncat</code>, <code>snprintf</code>。<code>[必须]</code></p>

<h3><a class="anchor" id="11.5-内存释放new!!!" href="http://review.iauto.net/developrule/CodingRule#11.5-%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BEnew!!!"><i class="fa fa-link"></i></a>11.5 内存释放<font color="red">new!!!</font></h3>

<ul>
<li>内存释放时,需要使用正确的内存释放函数并按照正确的使用方法来释放。<code>[必须]</code></li>
</ul>

<p>例子1(没有分配内存却被释放的例子)：
</p><pre class="highlight"><span class="err">char **ap, *argv[10], *inputstring;
for (ap = argv; (*ap = strsep(&amp;amp;inputstring, " \t")) != NULL;)
if (**ap != '\0')
if (++ap &amp;gt;= &amp;amp;argv[10])
break;
/.../
free(ap[4]);
</span></pre>

<p>例子2(内存分配释放的函数配对用错了)：
</p><pre class="highlight"><span class="err">void foo(){
BarObj *ptr = new BarObj()
/* do some work with ptr here */
...

free(ptr);/*应当使用:delete ptr;*/
}
</span></pre>

<h2><a class="anchor" id="12.-注释" href="http://review.iauto.net/developrule/CodingRule#12.-%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12. 注释</h2>

<p>通常注释分为两大类：</p>

<ul>
<li>文档注释

<ul>
<li>为了生成<a href="http://www.doxygen.org/index.html">Doxygen</a>文档的注释，使用<code>/** ... */</code>或者<code>/// ...</code>的形式。</li>
</ul></li>
<li>代码注释

<ul>
<li>一般的C++注释，使用<code>/* ... */</code>或者<code>// ...</code>的形式。</li>
</ul></li>
</ul>

<table><thead>
<tr>
<th>分类</th>
<th>写法</th>
<th>用途</th>
</tr>
</thead><tbody>
<tr>
<td>文档注释</td>
<td><code>/** 注释 */</code></td>
<td>区块说明</td>
</tr>
<tr>
<td></td>
<td><code>/// 注释</code></td>
<td>区块的简易说明</td>
</tr>
<tr>
<td></td>
<td><code>/**&lt; 注释 */</code></td>
<td>代码行说明</td>
</tr>
<tr>
<td></td>
<td><code>///&lt; 注释</code></td>
<td>代码行说明</td>
</tr>
<tr>
<td>代码注释</td>
<td><code>/* 注释 */</code></td>
<td>长文/多行注释</td>
</tr>
<tr>
<td></td>
<td><code>// 注释</code></td>
<td>简短注释</td>
</tr>
</tbody></table>

<ul>
<li>头文件（<code>.h</code>文件）中的定义、声明必须有doxygen文档注释。（参考<a href="http://review.iauto.net/developrule/CodingRule#12.1-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A">12.1</a>）<code>[必须]</code></li>
<li>源文件（<code>.c</code>/<code>.cpp</code>文件）中必须要有合理的注释。

<ul>
<li>以下仅限于在源文件（<code>.c</code>/<code>.cpp</code>文件）中定义并使用的内容必须要有注释。<code>[必须]</code>

<ul>
<li><code>struct</code>，<code>enum</code>，<code>union</code>，<code>class</code>定义</li>
<li>macros定义</li>
<li>全局常量、变量</li>
<li>静态函数、内部函数</li>
</ul></li>
</ul></li>
</ul>

<p>※注意：注释的内容使用英文书写。<code>[必须]</code></p>

<h3><a class="anchor" id="12.1-文档注释" href="http://review.iauto.net/developrule/CodingRule#12.1-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12.1 文档注释</h3>

<p>※注意：下面写的示例中，doxyen的注释风格只是推荐的写法，实际代码/文件中不做限制，但是为了统一风格，必须选择<a href="http://review.iauto.net/developrule/CodingRule#12.-%E6%B3%A8%E9%87%8A">12</a>中规定的文档注释风格。</p>

<p>doxygen的@brief关键字（概要说明的关键字）可以省略。此时需要doxygen生成工具的配置选项里设置下面属性。</p>

<ul>
<li>JAVADOC_AUTOBRIEF = YES</li>
</ul>

<h4><a class="anchor" id="12.1.1-文件注释" href="http://review.iauto.net/developrule/CodingRule#12.1.1-%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12.1.1 文件注释</h4>

<p>在所有的文件（不仅限于C/C++的头文件和源文件）开头都需要加入如下的版权信息。<code>[必须]</code></p>

<pre><code>Copyright @ 2013 - 2014 Suntec Software(Shanghai) Co., Ltd.
All Rights Reserved.

Redistribution and use in source and binary forms, with or without
modification, are NOT permitted except as agreed by
Suntec Software(Shanghai) Co., Ltd.

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
</code></pre>

<p>说明：  </p>

<ol>
<li><code>@ 2013 - 2014</code>中的<code>2013</code>和<code>2014</code>可以根据需要修改成合适的年份，例如<code>@ 2011 - 2015</code>。（一般来说，前面一个是文件第一次产生的年份，后面一个是当前的年份）<br></li>
<li>如果第一次创建文件的年份是当前年份，可以写成<code>Copyright @ 2014 Suntec Software(Shanghai) Co., Ltd.</code></li>
</ol>

<p>除了版权信息之外，C/C++文件的开始、结尾应该还有下面的注释。</p>

<h5><a class="anchor" id="12.1.1.1-头文件注释" href="http://review.iauto.net/developrule/CodingRule#12.1.1.1-%E5%A4%B4%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12.1.1.1 头文件注释</h5>

<ul>
<li>头文件开始的注释<code>[必须]</code>

<ul>
<li>版权信息</li>
<li>文件说明</li>
<li>头文件保护宏</li>
<li>C++头文件声明（如果是C++头文件时）</li>
</ul></li>
</ul>

<p>下面示例的内容是C/C++头文件都必需的。
</p><pre class="highlight"><span class="cm">/**
 * Copyright @ 2013 - 2014 Suntec Software(Shanghai) Co., Ltd.
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are NOT permitted except as agreed by
 * Suntec Software(Shanghai) Co., Ltd.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */</span>
<span class="cm">/**
 * @file Sample.h                                            ← @file关键字
 * @brief Declaration file of class Sample.                  ← 文件概要说明
 *
 * This file includes the declaration of class Sample, and   ← 文件详细说明
 * the definitions of the macros, struct, enum and so on.
 *
 * @attention used for C++ only.
 */</span>

<span class="cp">#ifndef SAMPLE_H                                             ← 头文件包含保护
#define SAMPLE_H
</span></pre>


<p>如果是<code>C++</code>头文件，在头文件包含保护红之后，必须追加下面的内容来注明是C++头文件。<code>[必须]</code>
</p><pre class="highlight"><span class="cp">#ifndef __cplusplus
#    error ERROR: This file requires C++ compilation (use a .cpp suffix)
#endif
</span></pre>


<ul>
<li>头文件结尾的注释<code>[必须]</code></li>
</ul>

<p>下面示例的内容是C/C++头文件都必需的。
</p><pre class="highlight"><span class="cp">#endif </span><span class="cm">/* SAMPLE_H */</span><span class="cp">      ← 头文件包含保护
</span><span class="cm">/* EOF */</span>
</pre>


<h5><a class="anchor" id="12.1.1.2-源文件注释" href="http://review.iauto.net/developrule/CodingRule#12.1.1.2-%E6%BA%90%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12.1.1.2 源文件注释</h5>

<ul>
<li>源文件开始的注释<code>[必须]</code>

<ul>
<li>版权信息</li>
</ul></li>
</ul>

<p>下面示例的内容是C/C++源文件都必需的。
</p><pre class="highlight"><span class="cm">/**
 * Copyright @ 2013 - 2014 Suntec Software(Shanghai) Co., Ltd.
 * All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are NOT permitted except as agreed by
 * Suntec Software(Shanghai) Co., Ltd.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 */</span>
</pre>


<ul>
<li>源文件结尾的注释<code>[必须]</code></li>
</ul>

<p>下面示例的内容是C/C++源文件都必需的。
</p><pre class="highlight"><span class="cm">/* EOF */</span>
</pre>


<h4><a class="anchor" id="12.1.2-class注释" href="http://review.iauto.net/developrule/CodingRule#12.1.2-class%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12.1.2 <code>class</code>注释</h4>

<p><code>class</code>定义必须有下面的注释说明。<code>[必须]</code></p>

<table><thead>
<tr>
<th>要求</th>
<th>项目</th>
<th>关键字</th>
<th>内容</th>
</tr>
</thead><tbody>
<tr>
<td><code>[必须]</code></td>
<td>概要说明</td>
<td>无</td>
<td>必须写在一行之内</td>
</tr>
<tr>
<td><code>[必须]</code></td>
<td>详细说明</td>
<td>无</td>
<td>描述详细说明。<br>如有必要，可以列一些条目形式的内容，或一些SampleCode</td>
</tr>
<tr>
<td></td>
<td>注意事项</td>
<td>@attention</td>
<td>描述使用class时的注意事项。<br>（例如限定只有某个模块可以使用等）</td>
</tr>
<tr>
<td></td>
<td>警告</td>
<td>@warning</td>
<td>描述警告信息。<br>（例如：计划删除等等）</td>
</tr>
<tr>
<td></td>
<td>参考</td>
<td>@see</td>
<td>描述一些参考信息。<br>（例如：应该要看哪些式样书、资料等）</td>
</tr>
<tr>
<td></td>
<td>其他项目</td>
<td>@bug</td>
<td>描述一些还未修改正的已知的bug等</td>
</tr>
</tbody></table>

<p>写法示例：<code>[推荐]</code>
</p><pre class="highlight"><span class="cm">/**
 * class概要说明。
 *
 * 空一行后开始写class详细说明。
 * 注意这里即使有换行，生成的文档中也不会换行，如果想要换行，像下面一样加入空行，
 * 或者使用html的标签&lt;br&gt;。
 *
 * 这样空一行后的内容会在文档中另起一行，下面的每个条目也会单独一行显示。
 * - 条目1
 * - 条目2
 */</span>
<span class="k">class</span> <span class="nc">Sample</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre>


<h4><a class="anchor" id="12.1.3-函数注释" href="http://review.iauto.net/developrule/CodingRule#12.1.3-%E5%87%BD%E6%95%B0%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12.1.3 函数注释</h4>

<p>函数声明必须有下面的注释说明。<code>[必须]</code></p>

<table><thead>
<tr>
<th>要求</th>
<th>项目</th>
<th>关键字</th>
<th>内容</th>
</tr>
</thead><tbody>
<tr>
<td><code>[必须]</code></td>
<td>概要说明</td>
<td>无</td>
<td>必须写在一行之内</td>
</tr>
<tr>
<td><code>[必须]</code></td>
<td>详细说明</td>
<td>无</td>
<td>描述详细说明。<br>如有必要，可以列一些条目形式的内容，或一些SampleCode</td>
</tr>
<tr>
<td><code>[必须]</code></td>
<td>参数</td>
<td>@param</td>
<td>先写参数名，留一个空格后描述参数说明。<br>需要明确输入/输出信息。<br>输入：[IN]        输出：[OUT]        输入输出：[IN/OUT]<br><br>没有参数的时候，参数名位置写<code>None</code><br>参数有取值范围时，需要说明范围，如有单位也一起注明</td>
</tr>
<tr>
<td><code>[必须]</code></td>
<td>返回值</td>
<td>@return</td>
<td>描述返回值的意义<br>如果没有返回值，写成<code>None</code></td>
</tr>
<tr>
<td></td>
<td>返回值</td>
<td>@retval</td>
<td>有异常返回，或返回值有取值范围时，说明不同取值代表的意义。<br>一行列举一个（或者一个范围）返回值及其代表的意义。<br>说明数值范围时，需要注明范围，如有单位也一起注明。<br><br>必要时可以写多个<code>@retval ...</code><br>如果<code>@return ...</code>已经可以充分说明时，可以省略<code>retval</code>。</td>
</tr>
<tr>
<td></td>
<td>注意事项</td>
<td>@attention</td>
<td>描述使用class时的注意事项。<br>（例如限定只有某个模块可以使用等）<br>一般来说，至少要注明是同步/异步接口。<br>例如，<br><code>@attention Synchronous I/F.</code><br> 或 <br><code>@attention Asynchronous I/F.</code></td>
</tr>
<tr>
<td></td>
<td>警告</td>
<td>@warning</td>
<td>描述警告信息。<br>（例如：计划删除等等）</td>
</tr>
<tr>
<td></td>
<td>参考</td>
<td>@see</td>
<td>描述一些参考信息。<br>（例如：应该要看哪些式样书、资料等）</td>
</tr>
<tr>
<td></td>
<td>其他项目</td>
<td>@bug</td>
<td>描述一些还未修改正的已知的bug等</td>
</tr>
</tbody></table>

<p>写法示例：<code>[推荐]</code>
</p><pre class="highlight"><span class="cm">/**
 * 函数概要说明。
 *
 * 函数详细说明。写法和class详细说明相同。
 *
 * @param [IN] path  : 年。公历。（范围：1~9999、单位：年）
 * @param [IN] month : 月。（范围：1~12、单位：月）
 * @param [IN] day   : 日。（范围：1~31、单位：日）
 *
 * @return 返回输入日期参数对应的星期几。
 * @retval 0...6： 星期天...星期六
 * @retval 负值  : 输入参数错误
 *
 * @attention Synchronous I/F.
 */</span>
<span class="kt">int8_t</span> <span class="n">getDayOfWeek</span><span class="p">(</span><span class="kt">int8_t</span> <span class="n">year</span><span class="p">,</span> <span class="kt">int8_t</span> <span class="n">month</span><span class="p">,</span> <span class="kt">int8_t</span> <span class="n">day</span><span class="p">);</span>
</pre>


<p>函数的概要说明与详细说明之间必须空一行。<code>[必须]</code></p>

<p>如果函数非常简单（没有输入输出参数和返回值），也可以使用简单的注释说明。<code>[推荐]</code>
</p><pre class="highlight"><span class="c1">/// 非常简单的成员函数说明。
</span><span class="kt">void</span> <span class="n">simpleMethod</span><span class="p">();</span>
</pre>


<p>OverLoad的方法使用<code>//{@ ... //@}</code>的方式来说明。<code>[推荐]</code></p>

<p>此时，必需对所有函数的每个参数依次逐个说明。<code>[必须]</code></p>

<p>例如，
</p><pre class="highlight"><span class="c1">//{@
</span><span class="cm">/**
 * 共同的简单说明。
 *
 * @param [IN] name : 指定名称
 * @param [IN] name : 指定名称
 */</span>
<span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">setName</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">);</span>
<span class="c1">//@}
</span></pre>


<p>在源文件中，函数注释只需要概要说明。<code>[推荐]</code></p>

<p>例如，
</p><pre class="highlight"><span class="c1">// 函数概要说明
</span><span class="kt">int8_t</span> <span class="nf">getDayOfWeek</span><span class="p">(</span>
                    <span class="kt">int8_t</span> <span class="n">year</span><span class="p">,</span>
                    <span class="kt">int8_t</span> <span class="n">month</span><span class="p">,</span>
                    <span class="kt">int8_t</span> <span class="n">day</span>
                    <span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre>


<h4><a class="anchor" id="12.1.4-枚举类型注释" href="http://review.iauto.net/developrule/CodingRule#12.1.4-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12.1.4 枚举类型注释</h4>

<p><code>enum</code>声明及其枚举值必须有注释说明。<code>[必须]</code></p>

<p>写法示例：
</p><pre class="highlight"><span class="c1">/// 月的枚举定义
</span><span class="k">enum</span> <span class="n">Month</span>
<span class="p">{</span>
    <span class="n">JAN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>       <span class="c1">///&lt;  1月
</span>    <span class="n">FEB</span><span class="p">,</span>           <span class="c1">///&lt;  2月
</span>    <span class="p">...</span>
    <span class="n">DEC</span>            <span class="c1">///&lt; 12月
</span><span class="p">};</span>
</pre>


<h4><a class="anchor" id="12.1.5-struct注释" href="http://review.iauto.net/developrule/CodingRule#12.1.5-struct%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12.1.5 <code>struct</code>注释</h4>

<p><code>struct</code>定义及其成员必须有注释说明。<code>[必须]</code></p>

<p>写法示例：
</p><pre class="highlight"><span class="c1">/// MyStruct概要说明
</span><span class="k">struct</span> <span class="n">MyStruct</span>
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span>     <span class="n">name</span><span class="p">;</span>    <span class="c1">///&lt; 变量name的说明
</span>    <span class="kt">int32_t</span>   <span class="n">length</span><span class="p">;</span>  <span class="c1">///&lt; 变量length的说明
</span><span class="p">};</span>
</pre>


<h4><a class="anchor" id="12.1.6-其他注释" href="http://review.iauto.net/developrule/CodingRule#12.1.6-%E5%85%B6%E4%BB%96%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12.1.6 其他注释</h4>

<p>常量以及变量定义，定义前写注释说明。<code>[推荐]</code>
</p><pre class="highlight"><span class="c1">/// 常量MAX_PATH_LEN的说明
</span><span class="k">const</span> <span class="kt">int32_t</span> <span class="n">MAX_PATH_LEN</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>

<span class="c1">/// 变量name的说明
</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
</pre>


<p>连续定义变量时，也可以把注释说明写在定义后面。
</p><pre class="highlight"><span class="kt">char</span><span class="o">*</span>   <span class="n">m_name</span><span class="p">;</span>    <span class="c1">///&lt; 变量m_name的说明
</span><span class="kt">int32_t</span> <span class="n">m_length</span><span class="p">;</span>  <span class="c1">///&lt; 变量m_length的说明
</span></pre>


<p>如，<code>class</code>的成员变量推荐使用下面的注释说明的书写方式。<code>[推荐]</code>
</p><pre class="highlight"><span class="k">class</span> <span class="nc">MyClass</span>
<span class="p">{</span>
    <span class="p">...</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int8_t</span> <span class="n">m_year</span><span class="p">;</span>      <span class="c1">///&lt; 年
</span>    <span class="kt">int8_t</span> <span class="n">m_month</span><span class="p">;</span>     <span class="c1">///&lt; 月
</span>    <span class="kt">int8_t</span> <span class="n">m_day</span><span class="p">;</span>       <span class="c1">///&lt; 日
</span>    <span class="p">...</span>
<span class="p">};</span>
</pre>


<h3><a class="anchor" id="12.2-代码注释的写法" href="http://review.iauto.net/developrule/CodingRule#12.2-%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%E7%9A%84%E5%86%99%E6%B3%95"><i class="fa fa-link"></i></a>12.2 代码注释的写法</h3>

<h4><a class="anchor" id="12.2.1-代码注释" href="http://review.iauto.net/developrule/CodingRule#12.2.1-%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12.2.1 代码注释</h4>

<p>代码注释是在说明代码行用途、说明以及注意事项等时适用。</p>

<p>注释的方式有很多种，不过注意不要和doxygen预定的注释方式冲突。<code>[推荐]</code>
</p><pre class="highlight">  <span class="cm">/******************************************
   不要使用这样的注释！Doxygen会使用类似的注释。
  *******************************************/</span>

  <span class="c1">////////////////////////
</span>  <span class="c1">/// 也不要这样进行注释 ///
</span>  <span class="c1">////////////////////////
</span></pre>


<p>下面是推荐的几种注释方式。<code>[推荐]</code>
</p><pre class="highlight">  <span class="c1">// 用于单行注释
</span>
  <span class="cm">/*
   * 用于多行注释
   */</span></pre>


<h4><a class="anchor" id="12.2.2-不要写无用的注释" href="http://review.iauto.net/developrule/CodingRule#12.2.2-%E4%B8%8D%E8%A6%81%E5%86%99%E6%97%A0%E7%94%A8%E7%9A%84%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12.2.2 不要写无用的注释</h4>

<p>注释的目的是增强代码的可读性。如果对可读性没有帮助，那就不要写。<code>[推荐]</code></p>

<p>好的代码（比如完全遵守本规范的代码），如果能做到命名准确而又有意义，代码行清晰，代码结构明了，那代码的本身就是最好的注释。但是如果代码中涉及到某些特殊的信息，比如为了处理某种特殊情况而打了一个补丁，又或者写了一个很精良但是复杂的算法，那么最好加上注释。</p>

<h4><a class="anchor" id="12.2.3-}和#endif后的注释" href="http://review.iauto.net/developrule/CodingRule#12.2.3-}%E5%92%8C#endif%E5%90%8E%E7%9A%84%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12.2.3 <code>}</code>和<code>#endif</code>后的注释</h4>

<p>控制逻辑比较复杂的代码里，经常会出现大量的<code>}</code>和<code>#endif</code>，弄清他所对应的代码经常是要做，但又很麻烦的事情，这种地方请一定要加注释。<code>[推荐]</code></p>

<ul>
<li><code>}</code>后面加注释的例子：</li>
</ul>

<pre class="highlight">  <span class="k">if</span> <span class="p">(</span><span class="n">condition1</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">another</span><span class="o">-</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
         <span class="p">...</span>
      <span class="p">}</span> <span class="c1">// End of another-condition
</span>  <span class="p">}</span> <span class="c1">// End of condition1
</span>  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">condition2</span><span class="p">)</span> <span class="p">{</span>
     <span class="p">...</span>
  <span class="p">}</span> <span class="c1">// End of condition2
</span>  <span class="k">else</span> <span class="p">{</span>
     <span class="p">...</span>
  <span class="p">}</span>
</pre>


<ul>
<li><code>#endif</code>后面加注释的例子：</li>
</ul>

<pre class="highlight"><span class="cp">#ifdef COMPILE_OPTION1
</span>    <span class="p">...</span>
<span class="cp">#else // End of COMPILE_OPTION1
</span>    <span class="p">...</span>
<span class="cp">#endif // End of !COMPILE_OPTION1</span></pre>


<h4><a class="anchor" id="12.2.4-用#if-0-...-#endif取代大段的代码注释" href="http://review.iauto.net/developrule/CodingRule#12.2.4-%E7%94%A8#if-0-...-#endif%E5%8F%96%E4%BB%A3%E5%A4%A7%E6%AE%B5%E7%9A%84%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A"><i class="fa fa-link"></i></a>12.2.4 用<code>#if 0 ... #endif</code>取代大段的代码注释</h4>

<p>经常会需要把大段代码注释掉，这种工作下最好是用<code>#if 0 ... #endif</code>来做。<code>[推荐]</code></p>

<p>例如，
</p><pre class="highlight"><span class="c">#if 0  // 以下是被注释的代码

    a-large-code-section

#endif // 以上是被注释的代码
</span></pre>


<h2><a class="anchor" id="13.-附录A1-信息安全防御用代码规范（OEM-T社）" href="http://review.iauto.net/developrule/CodingRule#13.-%E9%99%84%E5%BD%95A1-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E9%98%B2%E5%BE%A1%E7%94%A8%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%EF%BC%88OEM-T%E7%A4%BE%EF%BC%89"><i class="fa fa-link"></i></a><font color="red">13. 附录A1-信息安全防御用代码规范（OEM-T社）</font></h2>

<h3><a class="anchor" id="13.1~11-链接" href="http://review.iauto.net/developrule/CodingRule#13.1~11-%E9%93%BE%E6%8E%A5"><i class="fa fa-link"></i></a>13.1~11 链接</h3>

<p><a href="http://review.iauto.net/developrule/codingRuleTSecurity">http://review.iauto.net/developrule/codingRuleTSecurity</a> </p>

<pre><code></code></pre>
    </div>
  </div>
  </div>

</div>
<div id="footer">
  <p id="last-edit">Last edited by <b>tianlu (tianlu)</b>, 2015-11-12 15:49:18</p>
  <p>
    <a id="delete-link" href="http://review.iauto.net/developrule/CodingRule" data-confirm="Are you sure you want to delete this page?"><span>Delete this Page</span></a>
  </p>
</div>
</div>

<form name="rename" method="POST" action="http://review.iauto.net/rename/developrule/CodingRule">
  <input type="hidden" name="rename">
  <input type="hidden" name="message">
</form>




</body></html>