1.原型模式，模板方法
  用原型实例指定创建对象的种类，并通过拷贝这些原型创建的新对象
  
  

2。观察者模式
  定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，
  所有依赖于它的对象都得到通知并被自动更新。
  它还有两个别名，依赖(Dependents)，发布-订阅(Publish-Subsrcibe)。
  
3.单例模式
   把构造函数定义为私有的，然后提供一个静态变量作为外界访问的接口

 //Singleton.h
class Singleton  
{
public:
	static Singleton* GetInstance();
private:
	Singleton() {}
	static Singleton *singleton;
};
//Singleton.cpp
Singleton* Singleton::singleton = NULL;
Singleton* Singleton::GetInstance()
{
	if(singleton == NULL)
		singleton = new Singleton();
	return singleton;
}
  
4.建造者模式
  将一个复杂对象的构建与它的表示分离，使得同样的构建可以创建不同的表示
  对于客户来说，只需要向导知道就行了，通过向导就可以构造复杂的对象
  
  
5.外观模式
  系统提供给客户一个简单的对外接口，把里面的复杂结构都封装起来，客户只使用简单的接口
  （1）它对客户屏蔽子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便。
  （2）它实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件往往是紧耦合的。
  （3）如果应用需要，它并不限制它们使用子系统类。

6.享元模式:运用共享技术有效的支持大量细粒度的对象
   降低内存中对象的数量，但使得系统更加复杂
   检查是否存在，不存在创建，存在返回
   
7.备忘录模式
  在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
  例如:保存游戏的进度
  
8.桥接模式
  定义：将抽象部分与它的实现部分分离，使他们都可以独立的变化，
  抽象和实现不再同一层次结构中，而是“子类化”他们，使他们都具有各自的子类，
  以便任意组合子类，，从而获得多维度组合对象
  目的：松耦合，高内聚，提高系统的可扩展性
  缺点：客户必须知道选择哪一种类型实现
  
9.代理模式
  定义：为其他对象提供一种代理以控制对这个对象的访问。
  有四种常用的情况：（1）远程代理，（2）虚代理，（3）保护代理，（4）智能引用
  
  
  
  
  
  
  
  
  
  
  
  